[{"title":"政策能否更进一步呢？","date":"2017-08-16T16:04:52.000Z","path":"2017/08/16/20170807-policy-a-step-further/","text":"由于出国留学需要长时间在境外，按照我国出入境的管理要求， 需要办理国际旅行健康检查证明书（俗称“小红本”），办理这个小红本的目的是万一出境的时候国内海关查，则必须要有。虽然听网上各路信息说，现在查这个东西的可能性极小，但我们毕竟是良民，还是去办一个好了。在办之前，了解到这样一个政策：对经批准出国留学1年以上的中国公民须凭护照、有效签证和境外学校出具的录取通知书等证明文件实施免费传染病监测体检(限“国际旅行健康检查证明书”所列项目，其他国家额外要求的体检项目不予免费)。这个政策在2017年4月1日以后正式生效，在网上查到这个的时候，心想：终于可以薅人民和国家一次羊毛了啊，这政策真是穷学生的一个福音啊，毕竟穷学生都是能省就省的。 就这样，我打电话给老家出入境的健康中心，看看都需要带什么东西才能免费体检制作这个小红本。在去之前，新生群里的各路小伙伴就分享了各地办小红本时候的“严格”要求：去美国留学，签证有效时间必须大于1年也就是365天。听到这个消息的时候，我心里咯噔了一下，由于签证被check，大使馆只给了我一年少几天的签证。去之前一天，我心里嘀咕着：估计这下悬了，但是明天还是要把我想说的有理有据并且冷静地说出来。 果然，第二天到了体检中心缴费窗口的时候，工作人员让我上交了i-20和签证，在她仔细检查签证的时候，我补充到：由于我被行政审核，所以签证只给了我一年不到一点，但是你看i-20，可以看到我这个项目是2年的，所以我是符合国家新出台的免费政策的。看我这样据理力争，工作人员说我叫我们主任来确定下吧，主任来了，我依然重复刚才的话，并且继续补充到：国家的政策的初衷是不是希望让出境留学一年以上的学生能够减轻点负担，享受这样一个福利呢？我的i-20上写着我的项目需要2年时间，那我是不是符合要求的，难道只是因为我被行政审核签证只给了一年不到一点，我的留学时间就缩短到1年以内了吗？主任说到：我们这儿要i-20和签证两个都要一年以上，才能免费，你这样的情况，我们没法免费！由于来之前就有心里预期，我把该说的说完，就去乖乖把钱交了然后做了体检。虽然结果是能够预料到，我也能够理解基层公务人员：涉及到钱的问题，人人都不想担责任，所以在对具体政策解释的时候，倾向于以最保险的做法来避免风险。在这个政策中，只是粗粗得说了“留学一年以上的公民凭各种文件可以享受免费体检”，但是这些文件是全部都要满足，还是仅仅满足一样，就可以了呢？这就没有具体说明了。政策执行的过程中，会遇到各种各样的场景，在考虑这个政策的时候，政策制定者大概没有想到：留学美国2年的项目，由于签证行政审核的原因，导致部分学生只拿到了一年的签证。这种情况，并不影响学生最终留学1年以上的事实，这个时候，政策解释能否更进一步，依政策初衷为出发点，也免去这部分学生的体检费用呢？如果可以的话，一个好政策也可以不断完善，真正达到让利于民的效果。记录下这件小事的原因是希望有点改变的，友邻们或者是能看到这篇文章的朋友们如果有相关部门的资源，是不是可以反映下，即使有一个地方的出入境健康中心先对政策解释更进一步了也是一个小进步啊。 政策来源网站：http://www.fs.gdciq.gov.cn/xxgk/xxgksx/sfgs/sfyjwj/201704/P020170401410058577874.pdf","tags":[{"name":"杂文","slug":"杂文","permalink":"http://yoursite.com/tags/杂文/"}]},{"title":"小议人身受到伤害威胁时候的防卫 -- 观《嫌疑人X的献身》有感","date":"2017-08-16T16:02:05.000Z","path":"2017/08/16/20170401-xianyifanXdexianshen-movie-review/","text":"昨晚跟同学一起去看了这部东野圭吾同名小说改编的电影，虽然之前没有读过原著，但是对东野圭吾的另一部作品《解忧杂货店》甚是喜欢，加上同学说《嫌疑人X的献身》日版电影很好看，所以还是蛮期待这部中文改编的版本的。整场电影看下来，我觉得大的地方都没啥问题，虽然王凯的表演有点浮夸，但是不太影响我认为这是部成功改编的电影。今天这篇影评，只是想写写关于这部电影的其中一个点：陈婧在过失杀人后的反应，以及之后因这件事情而引发的其他错误的行为。 陈婧之所以会最终勒死她的前夫傅坚，是因为前夫那天晚上再一次来骚扰她和她的女儿陈晓欣，不仅对陈婧进行殴打，还对她女儿动手动脚，这种禽兽的行为，让陈婧和陈晓欣的人身安全置于危险境地，而这时，陈婧拿绳子勒前夫的行为可以认为是正当防卫（不是专业人士，关于正当防卫举证和认定我不懂，这分析仅对电影中的行为有效），但是当最终她的前夫被勒死的时候，陈婧只表现出了是她杀死了傅坚，而没有一点觉得这是自己的一种防卫行为。看到这里的时候，还是有点小小叹息了一下，现实生活中，如果真遇到这种情况，我想大部分同胞应该也是这种反应，然后紧接着就是想着“自首”或是怎么掩盖自己“杀人”的事实，从这时起，才是他们犯错的开始。这个时候，我特地问了下同学，原著小说故事也是这样进行的吗？他说差不多。这样看来，这样一种“死者为大”的观念是中国和日本都存在的。很多人都认为如果一个人死了，那他的一些不致命的过错都是可以被忽略的，因为他没有造成别人的死亡，虽然可能开始的时候他有置人于死地的想法，而只是没有最终实现而已。 对比美国那边，是完全不一样的情况。记得前段时间有个新闻：一位中国留学生在密歇根东兰辛家里熬夜准备期末考试，半夜的时候，听到楼下有异响，想了下室友们都早在房间里面睡觉了，他觉得可能是入室盗窃或者抢劫的人发出的响声，然后他就拿出自己的枪，打开保险下楼，开了几枪，最终打死了其中一个嫌疑犯。最终当地警方没有起诉这位留学生，认为他的行为是正确的。如果这种事情是发生在国内，最终警方的处理结果是难以想象的。这位没有成功实施犯罪的人就这样“冤死”了。这里也可以看出美国跟中日相比，是把个人的权益和人身安全放在最重要的位置的。如果当一个人的人身安全受到威胁，他可以主动还击，并且“防卫过当”的情况下，可能还会免除处罚。 正是由于中日社会长期以来“死者为大”的观念，让陈婧在面对这种情况的时候，不知所措，最终石泓的加入让事情一错再错，导致了悲剧。如果我们的社会不是长期宣传这种“死者为大”，而将个人的权利提到更重要的位置，那慢慢得，以后遇到这样的事情，可能有越来越多的人选择“自首”，至于最终被认定为“正当防卫”或者是“防卫过当”甚至是“故意犯罪”，都比电影里面的结局要好很多，因为这反应了一种程序正义，而不是像电影里一样，都没有经过一套程序，陈婧就觉得自己犯了大罪了。","tags":[{"name":"影评","slug":"影评","permalink":"http://yoursite.com/tags/影评/"}]},{"title":"另一个世界，另一种生活 -- 观《冈仁波齐》有感","date":"2017-08-16T15:59:06.000Z","path":"2017/08/16/20170623-gangrenboqi-movie-review/","text":"在小城参加了这样一部文艺纪录片的“首映”，当然也可能是最后的放映，这样的文艺纪录片在商业片当道的今天确实没有什么商业的价值。下面来说说我观影的一些感受吧，涉及到一些剧透。 该纪录片讲述了芒康县一个村子里的一些人，组团去拉萨，去神山冈仁波齐朝圣的故事，这些人里面有想要因为杀了很多牦牛而赎罪的屠夫；有因为家里建房子死了两个人而想要为众生祈求平安幸福的普通人；还有即将临盆的孕妇；也有想要完成父亲遗愿的儿子。大家去朝圣的目的虽然不同，但同样的信念就是抵达他们心目中的神山。上路之后，就像西天取经遭遇九九八十一难一样，在几个月的朝圣路上，也发生了各种各样的“事故”，让我这个旁人觉得他们的旅程应该就此结束了吧，然而没有什么能让他们停下脚步。下面记录几个让我印象特别深刻的场景： 孕妇临盆。走到左贡附近的时候，孕妇快要生了，大家把她送到当地卫生院，生了个男娃后，我想，这下孕妇走不了了吧，孩子刚出生，她们俩总要回家了吧，然而并没有。团队在左贡休整了几天之后，这位新妈妈和其他人一起继续上路了，一路走一路跪拜，孩子哭了就上车给孩子喂奶。这样的情况我想在国内其他地方是难以想象的吧，说好的产后要坐月子的呢，说好的给孩子最好的呵护呢。 在走到离拉萨还有100多公里的时候，一辆越野车把朝圣团队的农用拖拉机给撞沟里了，拖拉机车头损坏。越野车司机很着急，慌忙解释是因为车上有一位危重病人要马上送到拉萨救治，开得太快不小心撞上的，团队看了看车里的人后，竟然就让越野车走了，没要一点赔偿。而他们干脆就把拖拉机头卸了扔在路边，用人力拉车上的补给前进。每拉一段路就把车停下，然后他们再走回去一路跪拜到车停的地方。 团队中的一位爷爷，抵达神山冈仁波齐山脚的时候，在一天晚上去世了，团队给他请了喇嘛，并且给他举办了天葬，接着他们又接着上路了。纪录片中的种种场景，都在表达在朝圣路上，什么情况都有可能发生：新生命的诞生、生活中的事故、生命的逝去，但是不管发生什么，都不能让他们停下朝圣的脚步。这难道不是人生的终极意义么？人生路漫漫几十年，体味人间酸甜苦辣咸，但怎么样都不能停止前进的脚步啊。在观影的过程中，我一直在想除了他们的宗教信仰之外，还有什么客观的东西让他们能这样走下去：每天可能只能前进几公里，总共1000多公里的路程。他们在村子里的生活很简单，吃得简单，能做得事情也少。简单的生活让他们的欲望也很少，在真正决定做一件需要长期坚持的事情的时候，他们也不容易被外界干扰和诱惑。我想我是怎么都不可能这样去走上千公里的路的，路上遇到车祸怎么办？山崖塌方了怎么办？脚崴了怎么办？路上睡觉怎么办？朋友圈发不了怎么办？这样走，营养跟不上了怎么办？你看，就是有这么多干扰和诱惑，让人们根本都不会出发。写这篇影评的原因，不是想拔高所谓信仰的力量，不同世界的人有不同的活法，只是看到朝圣的藏民们的活法，觉得被震惊了，虽然活法不同，但也有东西是相同的：朝圣之路亦是人生路，出发了就走下去，路上遇到什么事情也别回头啊，终有一天，会抵达每个人心中的神山。最后真心感谢导演和制作团队，谢谢你们带我感受两个小时的另一个世界和另一种生活。我心目中好电影的一个标准是: 它能不能让我感受到我平时生活中根本无法感受的东西，从这一点来看，这部电影是我心目中的五星电影。","tags":[{"name":"影评","slug":"影评","permalink":"http://yoursite.com/tags/影评/"}]},{"title":"Princeton_Algorithm PartI 作业总结分析","date":"2017-08-16T15:51:58.000Z","path":"2017/08/16/20170629-princeton-algorithm-part1-summary/","text":"Week1: Percolation主要思路 想要达到Percolation的状态，则要一个正方形的矩阵块中，从顶到底，一个小块能通过与其前后左右的方块连通，并由此传递到底部的方块。 采用WeightedQuickUnionFind将已经open的方块union起来，可以形成一串已经open的方块，之后每次新open一个方块，用find方法，来判断parent方块是否与顶或者底连通。 如果一个方块，与顶和底都能连通，此时整个矩阵块达到Percolation的状态。一些注意点 将二维矩阵转化为一位，通过xyTo1D方法来实现，转化以后的数组用来记录某个方块是否open，是否与顶和底连通都状态信息。 当open了一个方块后，要将它与前后左右四块方块中已经open的连通起来，并且判断他们的parent是否与顶或者底连通。 注意边界问题，行和列的取值大于等于1，小于等于n；并且，如果第一行或者第n行的方块open了，那此方块的parent方块与顶或者底也就连通了。 (double)percolation.numberOfOpenSites()/(range*range)前面要用double进行强转，因为分母大于分子，并且都是int型，如果不进行强转，相除之后的值为0。 Week2: Queue主要思路 Deque使用的数据结构是定义一个内部类Node，其中一个node里有： 泛型 Item – 当前节点 Node prev – 前节点 Node next – 后节点 RandomizedQueue则采用可变长度的数组： 当元素个数增加到当前数组最大长度时，则将数组容量翻倍。 当元素个数减少到当前数组最大长度的1/4时，则将数组容量缩小到一半。###一些注意点 Deque的四个方法：addFirst/addLast/removeFirst/removeLast的主要目的就是建立相邻两个节点之间的双向连接，增加和删除首尾节点时，新节点与前节点或者后节点的连接该变动的变动。拿addFirst举例： 在头节点前增加新节点，则原来的first节点变成oldFirst。 此时要新建一个节点first = new Node()，并且赋值：first.item = item + first.next = oldFirst。 判断极限情况：如果当前Deque为空，则first和last节点相同；如果不为空，则oldFirst.prev = first，将旧first节点的前节点链接到当前的first节点。 RandomizedQueue最主要的一个特点就是每次调用iterator或者dequeue方法，都是取一个n范围内的随机数。例如迭代器的next方法里，用StdRandom.uniform(n)生成随机数，然后取出该值，并且将temp[index] = temp[i - 1]，然后将temp[i - 1] = null，释放存储空间。 Week3: Collinear主要思路Brute类型算法由于这个算法只要求找到4点共线，那就采用暴力枚举的方法，用4个循环，找4个点，分别计算后三点与第一个点的斜率，然后再比较斜率，如果三个斜率分别相等，再将4个点进行排序，线段就由最小点和最大点组成。 Fast类型算法 每个点都作为起始点，用slopeOrder()这个比较器来对Points数组进行排序。 接着比较斜率的大小，只要斜率一直相同，记录相同斜率线条的参数就一直自增，但只要一出现斜率不同，所有初始参数重置，不管此时是否达到要求有4点或以上的点共线。 为了避免重复计算的情况出现,只计算min点和tempPoints[0]点是同一个点的线段,因为每个循环都是想找以当前标准点为起始点的共线线段。 极限情况,如果最后一条斜率刚刚满足到dotCounts &gt;= 2,那把这条线段也要包括进来。 一些注意点 java程序的输入还是输出的array，一定要在程序内做个copy，不是仅仅copy reference，是把reference所指向的object也copy了。这样，当程序外面的array有变化的时候，不会影响程序内的数据，就是immutable的了！BruteCollinearPoints.java解释了为什么计算共线点的代码要写在构造函数里的原因:保证segments方法返回的value是不变的, 如果写在segments方法里面,可能会造成lineSegments对象还在改变的时候, 就返回了value。 尽量不要改变传入参数的数据结构，如果非要改变，则先copy到另外一个参数里去，在另外一个参数里去改变。 Point.java里的slopeComparator内部类，compare方法在比较斜率的时候，刚开始用了判断slope1 - slope2 == 0的方式，显然是错误的，因为斜率是double类型，而0是int型，真是低级的错误！ Week4: 8puzzle主要思路 8puzzle是一个九宫格，只有8个位置上有数字，想要把每个数字都按照从左到右从上到下顺序移动到各自的位置所需要的最优步数。 它有一个重要特性是：随意交换两个不为零的位置的数字，如果新的board可以最终移动到目标位置的话，那原来的board肯定是没有解的。 有两个距离： hamming：不在正确位置上的数字的个数 manhattan: 在错误位置上的数字离目标位置的距离（横向和竖向距离的和） neighbors定义：空位置与上下左右非空位置调换后的board，一个board最多会有四个neighbor，最少会有两个（在四个角上的情况）。 程序里面的MinPQ是一个priority queue，每次调用delMin方法，都会返回当前队列里面预计需要步数（priority = manhattan + current moves）最小的节点（node），这里把每移动一步都当做一个节点，直到先达到目标位置为止。 为了避免重复移动，如果上一步节点的board位置与当前board位置相同，则不用将此board当做一个节点加入MinPQ，代码中即是node.prev ！= null &amp;&amp; cur.prev.board.equals(board)。 等到所有位置都到目标位置之后，判断当前节点是否是twin节点，如果不是，则说明有解，则利用node.prev把刚才一步步都装进stack里，作为解的步骤；如果是，则说明原board无解。 一些注意点 遇到二维数组，慎用clone方法，因为复制了二维数组以后，每行的引用对象相同，复制的二维数组的变化会导致原数组也产生变化。 将原board和twin board放在一个MinPQ里最重要的原因是性能的考虑，而且由于这两者互斥，只要一个有解，另一个就是无解的，此时可以跳出while循环，进行下面的程序。 Week5: KdTree主要思路 作业题目的要求是给定平面内的一个矩形，找到离矩形内已知一点距离最近的点。 KdTree.java采用红黑二叉树算法和递归方式，逐步逼近离已知点最近的点；PointSET.java采用暴力枚举的方法，找到最近点以及矩形范围内包含的所有点的stack队列。 2d-tree在奇数层和偶数层的时候，对于矩形的分割是不同的，注意区分。 其他注意点请参照代码里的标注。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"传奇 -- 读《褚时健传》有感","date":"2017-03-22T03:29:10.000Z","path":"2017/03/21/20170307-chushijian-reading-notes/","text":"读《褚时健传》的感觉跟读《Elon Musk》和《Jobs》这两本传记的感觉是不同的，不管是Musk还是Jobs，在工作中总给人mean的感觉，而褚时健除了是个伟大的企业家之外，还是一个好人，一个懂得怎么与各种各样的人相处的智者。褚时健一生所经历的事情很多，书中介绍了那些大的节点，但正是这些节点，把褚时健的做人做事的品质都完整地表述了出来。这篇读后感仅记录一些我的个人想法，也以此来鞭策自己。 贵人人的一生肯定会遇到很多人，但是能称得上贵人的肯定是少数，而且有些人可能一辈子都没有机会遇到贵人。对于褚时健来说，书中描写了三个对褚时健的人生起了关键作用的贵人。 堂哥褚时俊褚时健少年的时候，由于父亲早逝，他要承担农活、家务活以及烤酒的活，加上他还喜欢拿鱼（抓鱼），小学毕业以后，就没有继续上学了。直到有一天，堂哥从镇上回村子，和褚时健一起烤鱼吃的时候，跟褚说了一番话，意思是觉得他很聪明，应该去昆明读书，看看外面的世界，而不是在家乡的村子里过一辈子。褚时健对于这个堂哥一直很信任，听了他的话以后，褚时健好像突然被点醒了一样，之后就去了昆明读中学，然后加入共产党。这个人生节点，可能对很多人来说并不会起什么作用，但是却是改变褚时健人生轨迹的一番话。这种感觉就像人突然被什么东西猛击了一下，然后就悟到了一些东西，这样的经历是无法复制的。从褚的经历里面，也让我回忆起一个改变我人生轨迹的老师。小学五年级之前，我的成绩只能算中等，如果是这样的成绩，是基本没希望进当地最好的初中的。五年级之后，我们换了一个数学老师姓项，项老师成为我们班数学老师之后第一个规定就是：“想参加数学竞赛的同学，数学竞赛的习题书‘必须’做到XX页”。这个规定跟之前的数学老师完全不一样，由于我害怕如果完不成就没有资格参加竞赛（我们小学竞赛一等奖就可以去最好的初中），小学五年级的时候我就自己自觉地到学校和住校生一起晚自习做习题。等到竞赛的时候，我发现其实没有几个人完成了项老师制定的目标，但是没影响他们参加竞赛。不过也正是由于我完成了目标，做了那么多竞赛习题，在那次至关重要的竞赛中，拿了一等奖，也就顺利进入了当地最好的初中。现在想想，如果没有项老师的“强制”的规定，我可能还是只能拿竞赛三等奖，然后也不知道有没有机会去读最好的初中。 普朝柱和朱奎普朝柱和朱奎是褚时健在玉溪卷烟厂时期的云南省的两位领导，褚时健接手玉溪卷烟厂之后的多项改革，都离不开这两位领导的支持，有些政策甚至是只为玉溪卷烟厂设立。这两位领导的想法和褚时健很一致，只要能为国家多创造税收收入，那什么改革都应该去试试，哪怕是违反一些规定的做法。褚时健也没让两位领导失望，不管是原料方面还是制烟工序以及设备的更新，最终都反应到销售收入和利润的不断增加。如果换了其他畏手畏脚，怕担责任的领导，褚时健在玉溪卷烟厂的改革之路在政策支持上肯定做不到这么顺利。而这种桎梏，会让很多烟厂的改革措施胎死腹中。 做事褚时健人生的大部分时候，都没有闲着，都在科学地做事，并且懂得让利与他人。 闲不住的人少年时期的褚时健，因为要帮着母亲分担家里的活，不管是农活、家务活还是烤酒拿鱼，他没闲着；到了后来去读书，加入共产党参加革命，也没闲着；甚至是后来被打成右派，入狱后出狱，还是没有闲着。用他自己的话来说：“闲着有什么意思”。对于他来说，闲不住要做事情，不是为了多少的名和利，他就是单纯得想把事情做好。正是因为褚时健这样的性格，也让他在做事的时候能够排除很多干扰和诱惑，专注于当前正在做的事情。 科学地做事少年时候在家里烤酒，褚时健就琢磨出怎么样烤酒才能让出酒量更多一点；后来在糖厂榨糖，找出亏损关键，加上把蔗糖渣利用起来烤酒，让糖厂的效益最终好起来；在玉溪卷烟厂的时候，更新制烟设备，改进流程工序，指导农户种出高质量的烟叶原料等；75岁高龄开始包山种橙，学习书里的知识，加大橙树种植的间距，挖水渠引水等。褚时健好像有种特殊的能力：就是每做一件事情，都能找到关键的点，然后去一个一个攻克难关，我想这跟老爷子不断学习知识并且总结经验的好习惯是分不开的。试想这世上有几个人能够活到老学到老，75岁以后种橙还接着研究如果科学地种橙，提高产量以及橙子的质量。 让利与福利糖厂时期的“以路换甘蔗”、“以酒换甘蔗”；玉溪卷烟厂时期，拨款给农民种植烟叶，重金奖励对高质量烟叶种植做出贡献的技术专家；兴建楼房，改善卷烟厂职工的居住环境。这些让利与合作伙伴，给基层员工真正福利的做法，让褚时健不管在对内还是对外事务上，都慢慢能得心应手起来。同时他自己也总结出：“要想做成一件事，必须让相关各方能够利益平衡，都能从中获利。” 人生关键节点上遇到的贵人们，以及褚时健做事的方法与态度，成就这样一段传奇的人生。面对一次次的人生低谷：少年丧父，被打成右派，被判贪污，褚时健总能从脚踏实地做事开始，慢慢恢复回来，这样顽强并且旺盛的生命力真不是每个人都能有的啊。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"《厚土》读后感","date":"2017-03-22T03:27:58.000Z","path":"2017/03/21/20170307-houtu-reading-notes/","text":"作为一个95的在读大学生，肖亚洲的这本纪实文学主要呈现了问题，但是没有给出问题的具体解决方案，当然，说到解决农村问题的解决方案，也不是一个人或者几个人能够写出来的。在这本书中，肖同学总结归纳出的问题，就已经足够有震撼力了。在这篇读书笔记里，我会分四个方面（生产、生活、教育和医疗）来进一步说一说肖同学书里比较触动我的那些场景。 生产 由于国家的退耕还林政策以及地方政府希望帮助农民致富，所以枣树成了很重要的一个品种，大规模地栽种于石楼县以及周边几个县里，“但是在推进过程中往往热衷于‘大干快上’，要求一定时间内完成种植面积多少亩，较少考虑市场变化以及全国同类产品种植面积、产量和发展趋势”（P36）。不管是退耕还林政策还是地方政府，初衷都是好的，不过在具体政策落地的时候，就打了很大的折扣，没有考虑到不同地方的差异性，退耕还林过程中搞一刀切。我试着从以下几个方面分析下出现这种问题的原因： 地方政府一级一级下来，在对政策初衷的理解上慢慢出现了偏差，用工科里面的话来讲，就是信息出现了噪声，导致传到最底层执行者的时候，他们根本就把政策的初衷抛到九霄云外了。因为缺乏对政策目的明确地了解，有些地方官员甚至把政策的执行过程当成了往自己口袋里面装钱的好机会。 缺乏科学精神。底层的政策执行者没有必要的知识储备，例如在退耕还林的过程中，没有考虑到不同地区因土地、气候等自然条件的不同，而一刀切地种植了大面积的枣树，导致了枣的品质很低，在市场化的竞争中败下阵来。写到这里的时候，想起了前段时间读的《褚时健传》，褚时健在70岁以后开始包山种橙子以后，一直致力于用科学的手段种植橙子，包括自己买书来学习种橙的技巧，培训专业的技术人员等。虽然说一边是公共事业，一边是私人事业，但是这种科学的精神是相通的。 另外一个生产方面的问题是农民很难通过正规的渠道融到创业的资金。农民主要的融资渠道有：家庭积累、亲戚朋友筹借以及民间借贷，而民间借贷通常是以高利的形式（利息高达2分至3分，年化收益24%-36%的利息）。这样一来，农民的融资成本很高，在创业的过程中即使成功了，也很难盈利（如果资金是通过高利的方式筹借过来的话）。在这几个融资渠道里面，唯独没有像银行或者小贷公司等的身影。作为小贷公司来讲，由于它的逐利本性，不做农民借贷这块业务可以理解；但是作为银行来说，除了逐利的天性以外，它应该承担起为农民提供普惠金融服务这个社会责任。 生活 “易地搬迁”这个也是政府好心办坏事的典型。“易地搬迁”是指政府统一规模建新的房子，将存在地质隐患或者交通不便的位置的农民搬迁到地势低一点的地方去，但是由于新搬迁的地方没有什么配套的设施（比如工厂）提供给农民就业的机会，大家还都是要回到以前的山上管理枣树以及其他农作物，这样一来，反倒是增加了农民的负担，因为有些农民的老家距离搬迁后的房子有10KM，山路不好，交通是个问题。这也可以看出，在政策制定的过程中，不能光考虑与政策相关的那些直接影响，比如易地搬迁，理想情况下是改善农民的居住环境，使农民不用再居住在海拔高的窑洞里，但是这个政策的执行过程中农民的生产和生活都出现了一些意想不到的坏结果。 “一村一井”与“易地搬迁”政策不同的是，“一村一井”政策属于政府帮农民把事情做到一半，因为农民无力承担剩下的一半的费用，导致前面一半的投资基本上都打了水漂。在政策制定的过程中，是否充分验证了各种可能性，比如在“一村一井”中，政府是否知晓即使帮助农民打了井，后续的维护以及浇水牵水管的费用，农民也无力承担这个事实。如果知道的话，有没有后续的解决方案；如果不知道的话，当初花这个钱去打井的意义在哪里？ 教育由于近10几年来，全国很大一部分的农村小学都被乡里或者镇里的学校所兼并，导致留守儿童必须要去更远的地方去读书，同时陪伴他们的还至少要有一个照顾起居的亲戚。在镇里或者县里租房，加上额外的生活开销，导致了一些家庭因为教育而致贫。国家实行了九年义务教育，没有到还是有农村家庭因子女上学而致贫，这个可以说是“防不胜防”么？面对这种情况，有些贫困家庭的孩子早早放弃了学业。但是他们又是生活中科技不断进步的时代，手机的普及让他们接触了外面的“世界”，然而因为缺乏必要的知识和技能，他们即使去城里工作，也无法真正融入城市，但是同时，他们也回不去了农村，使他们成为了“边缘人”。 医疗另一个使农民致贫的因素就是家中有人生了场大病，虽然国家在全国推行了农医保政策，但是当地一个现实是：偏远地区的医疗条件有限，要治好病就要去大城市的医院，而这样就无法进行报销，这让有些家庭只能举债给病人治疗，这样的因病致贫可能让一个家庭一辈子都无法翻身。 回顾书中比较触动我的几点以后，除了无法改变的自然条件以外（干燥少水，冬天寒冷等），政府在政策制定、执行以及反馈这样一个闭环当中，能够提高的地方还有很多。比如政策制定的过程中，是否考虑了一个政策的直接以及可能的间接影响；再比如政策执行的过程中，如何监督和培训实际执行人，让政策真正落地；还比如，如果政策执行过程中，出现了意想不到的情况，农民是否有一个反馈的渠道，将具体问题上报给政府。在各个过程中，出现问题不可怕，可怕的是没有双向沟通的机制，导致出现问题也无法解决。 路漫漫其修远兮，再次对肖同学的工作致以敬意。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"关于共享单车","date":"2016-12-22T08:02:35.000Z","path":"2016/12/22/20161222-about-sharing-bicycle/","text":"对于一个买一辆单车就丢一辆的人来说，最近关注到的“共享单车”可能能解决我的问题啊，虽然还没体验过，但它可能带来的一些变化让我感到既残酷又美好。 小偷们的好日子要到头了？高中和去年买的两辆单车都是不到一年就被偷走了，总结其原因是： 个人的单车没有GPS，丢失之后无法定位去寻找。 没有像公共自行车那样的统一标识，偷了之后在黑市卖出去很容易。很难想象小偷如果偷公共自行车再拿去卖是什么样一种情况。 违法成本低以及收益高：偷了报警也没用；一辆山地车就算折旧卖也有好几百。 而由公司大批量统一提供的共享单车，能把这些问题都解决得差不多： 市面上的新共享单车基本都有定位功能，因为要配合他们的”无桩”停车的服务。 公司提供的这种单车从形式上来说跟公共自行车差不多，并且提升了灵活性。 大批量提供的统一单车应该能大大降低偷盗率，甚至可能将为零，因为当小偷偷这样一种车的时候，放到黑市里面卖，想必也没人敢买。而如果小偷通过重新喷漆甚至改造一下这样的单车再拿去卖，这个成本以及麻烦程度可能会让小偷无利可图，既然没有利，那还偷它干嘛呢？想到这样一种未来：这种共享的单车基本满足日常人们的“最后一公里”需求，从而让大部分的人不需要拥有自己的单车。而单车爱好者们则把他们更加专业的单车只用于户外运动，让不同的车有各自不同的用途。 “无桩”与“有桩”随着定位与网络技术的不断成熟，公共自行车那套“有桩”停车系统以及相关的硬件（例如：桩、用来调度车辆的人以及大巴）竟然就这样被“无桩”停车从另一条赛道切入了。生产桩以及其他配套物件的公司大概没有想到自己的这块业务不是被相关的竞争对手吃掉，而是将被一个完全不同的概念吃掉，就像《三体》里面说得那样：“毁灭你，但与你无关”“无桩”的问题有很多，这里不讨论，因为还没有想得很明白，但“无桩”肯定是未来。新技术的产生与应用淘汰了旧有的技术，可能也会让部分人失业，真是残酷又美好。 关于幸福感由于单车被偷走，实在不想再买了，所以现在经常骑公共自行车，但有个问题是：在用车高峰期，我经常走好几个停车点都没有车，这种走到了才发现没车的感觉真是让人很无奈。然后就想着如果有一个系统，能查看身边的停车点是否有车，这样看到周围没车，就可以提前放弃单车出行，这种小幸福感的提升，我认为是科技应该给人类带来的。就像“酷米客”公交刚出来的时候，出门前就可以看下最近的一辆公交车什么时候来，而不用在公交车站没有“安全感”地等着。基于位置的共享单车加上无桩的形式慢慢也可以让人们感受到这种安全感，打开app，看到旁边没有车或者很远才有车，可以提前改变出行方式。 以上几点都是基于猜想，能否实现以及什么时候实现，拭目以待吧~_~","tags":[{"name":"杂文","slug":"杂文","permalink":"http://yoursite.com/tags/杂文/"},{"name":"科技","slug":"科技","permalink":"http://yoursite.com/tags/科技/"}]},{"title":"记一次Java内存占用过大排查","date":"2016-04-24T13:51:12.000Z","path":"2016/04/24/20160424-research-on-java-memory-overweighted/","text":"介绍背景介绍最近公司要上线一个Java后台服务，在最后性能测试的时候发现，高并发条件下，该服务内存占用居高不下（跑10个小时以上能飙到4G）。这样奇高的内存占用肯定是无法接受的，所以需要排查到底是哪里出问题了。 环境介绍 OS版本：CentOS release 6.5 (Final) JDK版本：1.7.0_79 排查过程以及踩的坑1. 查看Linux系统上Java内存情况a. 实时查看在Google的过程中，发现jmap这个JDK安装过程中自带的工具可以满足查看内存情况需求，所以就用命令行敲入jmap，但是显示command not found，说明jmap工具在远程主机中不存在。在查看了Java环境后发现，由于远程主机只需要运行Java服务，所以只装了JRE，没有装JDK，所以自然没有jmap工具。 接着就去下载了Linux版本的JDK，将安装包放在在/usr/java/目录下并解压，然后配置环境变量，完成JDK安装，用java -version检查是否安装成功。（踩得坑：由于我司提供256位数据加密服务，但由于出口限制，AES加密长度被限制为128位，这时候需要替换local_policy.jar和US_export_policy.jar两个jar包，否则无法正常加解密。路径在jdk里的jre目录下：/jre/lib/security） 准备好JDK环境之后，命令行输入：jmap -histo &lt;pid&gt; | head -20，就可以查看某个pid的java服务占用内存排名前20的类。注：该命令不适用子Windows系统里。 通过实时查看内存占用情况，发现占用内存最高的几个类大部分都是Netty的buffer相关类，那问题就可以确定存在于使用Netty框架时使用了buffer，但是没有调用buf.release()去释放buffer。 b. 把heap文件dump下来分析 jmap还有一个指令可以把整个内存情况转成文件形式保存下来：jmap -dump:format=b,file=filename.bin &lt;pid&gt; 从远程用sz filename.bin命令将文件下载到本地来，在用Eclipse插件MAT(Memory Analyse Tool)分析整个文件，MAT插件需要下载安装，方法Google可以找到。 注：在使用这个命令导出来的文件很大，但是最终MAT里分析出来的图表各个类占用的内存却很小，不知道是哪里出问题了，感到迷惑！ 不过在这个之前，由于启动脚本里设置了如果发生OOM则会将hprof文件dump出来，在其中一次测试中，.hprof文件就产生了，下载到本地用MAT进行分析后能看到以下结果： 这里面就能看到，ConcurrentHashMap占用了大部分的内存，所以问题定位到使用该map的代码里。另外MAT工具还有很只管的饼图来呈现哪些类占用了很大内存。 2. 解决方案a. 解决ConcurrentHashMap问题在Review代码之后，发现ConcurrentHashMap会将整个http请求放入缓存，当时这么做的原因是，我们其实是一个通信转发的框架，所以需要把每个请求记录下来，等远端有返回后，可以找到对应的Channel将Response返回。而实际上，不需要缓存整个http请求，只要把请求进来时候的Channel进行缓存即可，所以将ConcurrentHashMap的键值改成了&lt;String, Channel&gt;，其中String是UUID.randomUUID().toString()产生的随机字符串。 b. 解决Netty的buffer没有被release问题在Review代码之后，发现逻辑中有两个地方用到了ByteBuf： Http请求进来时，会将请求body缓存到ByteBuf里，这里是显式调用。解决：在返回Response之后将该buf释放掉。 HttpResponse中，也会先将返回body缓存到ByteBuf里，这里是隐式调用，刚开始都没发现。解决：显式生成ByteBuf对象，采用response.content().writeBytes(buf)方法写入response，写完之后，调用buf.release()方法。 注：关于ByteBuf释放问题，如果Netty中的Handler将buf传递给其它类使用，则无需调用buf.release()。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"多彩笔记(ColorfulNotes)_v1.0.0 _ 开发总结","date":"2016-02-27T05:28:34.000Z","path":"2016/02/26/20160226-colorful-notes-v1.0.0-dev-summary/","text":"数据库方面概述由于这个应用涉及到本地存储笔记应用，所以需要用到Android的ORM框架(Object-Relational Mapping)，市面上有好多ORM框架，例如: GreenDao、OrmLite、Afinal中的FinalDb、Realm等等。这次我采用的是FinalDb这个框架来进行数据的本地存储。下一款应用我打算用Realm或者GreenDao来做数据存储，之后也可以对比下这几个框架的优劣。下面我会记录一些我在使用FinalDb这个框架时候遇到的一些问题和总结。另外，FinalDb框架的增删改查源码分析会抽空专门写一篇来进行研究。 使用总结对象初始化1FinalDb db = FinalDb.create(this, NConstants.NOTE_DB_NAME); db对象初始化是用FinalDb类中的静态方法create方法来创建的，在create方法的内部逻辑中，会判断以NConstant.NOTE_DB_NAME这个名字命名的数据库是否已经存在，如果不存在，就会新建；如果存在，则会返回该数据库对象。在实际应用中，如果数据库是从res-raw资源文件夹中拷贝到sd卡上的，则需要在拷贝结束后，再初始化db对象。因为一般在拷贝前，先会判断数据库是否已经存在，如果已经初始化db对象，数据库文件已存在，则不会执行拷贝操作。 查找排序在某个笔记本下呈现全部笔记的页面里，会将最近操作过的笔记放在最前面的位置，所以从数据库读取笔记时，需要按时间进行降序排列，具体的实现代码是： 1list = db.findAllByWhere(Note.class, \"noteBookName='\" + noteBookName + \"'\", \"lastUpdateTimeInLong DESC\"); 而如果是需要升序排列，则把DESC改成ASC。 说到了时间排列的问题，另外还要记录一下的就是，数据库存储的最近更新时间有两个格式，一个是字符串类型，一个是long类型，其中字符串类型的时间带上了时区信息，便于记录笔记是在哪个时区的哪个时间创建或修改的，这样就避免了因为换时区，导致显示的时间不同的问题；long类型的时间就是为了降序排列而记录的。 非某个名字的查找下面的代码是用来查找除了某个名字之外的其它所有内容： 1list = db.findAllByWhere(NoteBook.class, \"name!='\" + values.getName() + \"'\"); 事件发布方面（EventBus）在笔记类应用中，由于在修改、移动、删除笔记操作时，都会伴随着其它页面的一些变动，所以也就需要一个消息总线来发布事件，订阅事件以实现程序间组件的通信，这里我选择了用得比较多的一个框架–EventBus。3.0.0版本的EventBus中register和post两种方法与之前版本相同，但是在事件处理的方式上有了很大的不同，例如之前使用的方法是： 12public void onEventMainThread(event) &#123;&#125; 而在3.0.0版本以后，使用注释来说明事件处理的线程： 123@Subscribe (threadMode = ThreadMode.MainThread)public void onUserEvent(event) &#123;&#125; 在刚开始进行开发时，对于发布的事件没有进行封装，这样一来，post出去的事件在处理的时候没有起到作用，例如在移动笔记时，会涉及到两个笔记本的数量变动，没有进行封装前，就会将全部的笔记本重新初始化一遍，这样的性能可想而知是不会高的。在后来的优化中，将涉及到的笔记本、笔记本的位置和笔记本操作类型(分为移动笔记和创建笔记本两种)封装成NoteBookEvent，在post的时候将NoteBookEvent对象发布出去，进而在处理事件时，只针对相关的笔记本进行操作，而不是全部笔记本初始化一遍。 印象笔记接入方面多彩笔记在功能设计时，就把接入印象笔记作为功能之一。在实际开发中，还是遇到了一些细节上的问题，值得记录下来。 登录回调印象笔记的登录回调支持两种模式: onActivityResult方法里面判断requestCode是否是EvernoteSession.REQUEST_CODE_LOGIN以及resultCode是否是RESULT_OK，如果是，则说明登录成功，接下来就是去获取用户信息的操作:evernote.getUser()。 另一种方式是实现ResultCallback接口，但是在多彩笔记应用里，由于Activity不是FragmentActivity，所以在实现ResultCallback接口的回调中，没法获取到用户登录是否成功的信息。 多彩笔记在印象笔记里的专属笔记本印象笔记的机制是：对于每个第三方接入的应用，由应用本身创建一个专属的笔记本用来同步笔记。所以在每次同步笔记之前，都要先检查专属的笔记本是否存在，如果不存在，则需要创建，具体实现方法是Evernote类里的makeSureNotebookExist(@NonNull String notebookName)。 相同笔记多次同步如何避免在印象笔记里重复出现印象笔记会个每条笔记设置一个唯一的guid，所以多彩笔记里，也把guid当作笔记的唯一识别码存储起来，在每次同步笔记时，会检查本地笔记的guid是否有值，如果没有，则说明是第一次上传，这样就需要创建一条印象笔记；如果有，则说明是更新笔记的操作，无需创建新的一条印象笔记。 单向同步（多彩笔记-&gt;印象笔记）多彩笔记只做了单向同步到印象笔记功能，除了我觉得对于小的笔记类应用来说，所产生的笔记大部分都只会向印象笔记汇聚，而没有必要进行反向同步，因为这类笔记应用的用户粘性不会高。还有一个原因是，多彩笔记也有笔记本的概念，同步到印象笔记之后，原有的笔记本信息没有办法保存，在进行反向同步时，也就没法找到原来的笔记本，所以也就索性没有做反向同步这个功能。 软键盘方面由于笔记里面需要键盘输入操作，所以要用到Android打开键盘以及关闭键盘的API，但是在实际开发以及测试过程中，目前还没有发现封装两个接口可以解决所以键盘打开和关闭的操作，所以这里只是把我在开发过程中遇到的一些情况给记录下来： 从一个Activity跳入另一个Activity需要自动打开键盘，有一个方法可以实现: 1getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE); 其它开启关闭键盘有效方法: 1234567891011121314public static void hideKeyboard(Activity activity) &#123; InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(activity.getWindow().getDecorView().getWindowToken(), 0); &#125; public static void hideKeyboard(Context context, View view) &#123; InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(view.getWindowToken(), 0); &#125; public static void showKeyboard(Context context) &#123; InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0); &#125; 上面hideKeyboard方法是在键盘关闭，关闭activity，键盘不会重新打开情况下也可以使用的，因为用户在输入文字之后，可能在键盘关闭或者打开的情况下去关闭activity，所以需要一个无论什么情况都能让键盘关闭的方法才能满足需求。 一些小问题 AsyncTask里的execute方法只能执行一次，如果重复执行，会导致程序崩溃，所以正确的处理是每次都new一个AsyncTask对象来进行操作 可滑动侧边栏drawerLayout设置背景颜色的方法drawerLayout.setScrimColor(getResources().getColor(R.color.black_transparency_12)); FloatingActionButton在xml文件里由layout_gravity设置时，初始化进入页面设置setVisibility为gone，会出现闪动一下再消失，影响美观；如果采用app:layout_anchor+layout_anchorGravity来对位置进行设置，则用setVisibility方法就不会有闪动的问题。 在笔记页面里，出现保存的“对勾”按键是由四个纬度来判断的： 笔记内容改变，出现保存按键 笔记标题改变，出现保存按键 所在笔记本改变，出现保存按键 笔记内容和笔记标题长度有一个不为零，出现保存按键 待写总结(单独出来)打包问题FinalDb分析与学习EventBus分析与学习","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"《硅谷之谜》读书笔记","date":"2016-01-24T06:38:38.000Z","path":"2016/01/24/20160124-secret-of-silicon-valley-read-notes/","text":"摘录 P23—虽然嬉皮士给人的印象通常是年轻人过度开放乃至乱来，比如穿着破损的牛仔裤、吸毒、滥交，但这都只是嬉皮士的表象，其深层埋藏着对传统价值观和思维方式的反叛，那些奇怪的表象实际上反映出年轻人试图树立自我意识却又迷茫的心态。对上一辈建立在有秩序的工业文明中的那种一板一眼的做事方式，以及在生活中保守中庸一丝不苟的价值观，嬉皮士们并不认同，他们尤其反对西方二战后的一代人所具有的那种冷战思维方式。嬉皮士们在思想上讲究平等和自由，并且以此探索新的价值观，在艺术创作上则通过吸毒等方式试图寻找灵感，尝试前所未有的创作。在个人行为上，他们试图通过标新立异来吸引社会注意，他们强调自我，很少仿照他人。这些人通常不追求物质享受，却在食不果腹时心怀世界。今天，在很多硅谷的公司里，包括苹果、Google和Facebook依然能够看到嬉皮士文化的影子。 P56—事实上，强调保护专利和强调创新是两回事，当一个公司必须依靠专利来维持自身的市场地位时，恰恰说明它在竞争中已经落伍了。一些大型的跨过公司，其主营业务的发展开始趋缓，而新的业务又开展不起来，只能靠并购和收取过去技术的专利费来增加收入，这些公司的法务部门甚至比工程部门更有发言权。但是，这恐怕对创新没有什么益处。 P61—从旧金山湾区的殖民过程可以看出，它和美国其他地区，比如东部以清教徒为主的北美十三州、南部的法属殖民地（如路易斯安那州）完全不同，传统的“美国人”的势力在旧金山湾区并不强，盎格鲁-撒克逊文化对这里的影响也不算强。这里后来在硅谷地区能形成多元文化的一个原因。 P62—不过，爱冒险这一点对后来硅谷的发展很重要，硅谷人不仅喜欢尝试新的东西，对失败也非常宽容，因为大家都知道在冒险中获得成功的是少数，这一传统保留至今。 P66—当然，加州的保守主义不等同于英国17-18世纪托利党那种支持等级并保留国王地位的主张，它在重视机会平等的同时，吸收了英国保守主义中强调自由经济、小业主利益、个人通过奋斗提升自己社会地位，以及“小河有水大河满”这种优先个人利益、淡化集体利益的价值观。……这种文化倾向带来的一个结果就是，大部分生意人在遇到问题时，习惯于靠自己的努力走出困境而不是寻求政府的帮助，这对硅谷的崛起有很大的帮助。 P82—IBM公司恰巧在计算机技术刚刚起步时就在美国西海岸开设了研发中心，这让旧金山湾区占到了天时；而当时在全球气候最好的地方居然空着几十平方公里的土地，可以提供给未来的新技术公司使用，又占到了地利；一个诺贝尔奖获得者靠自己的名气聚拢了一批世界上最优秀的技术人才，然后又把他们赶出去办了公司，又为湾区日后成为硅谷准备好了人的因素（不知道应该算是人和还是人不和）。 P110—风险投资两条金科玉律的准则： 投资就是投人，选对了人，就能把不好的项目变成一个好项目；投错了人，就会把一个本来有希望的好事搅得一团糟。 风险投资人要储备这种技术和管理人才，以便今后把他们派到所投的公司去挑大梁。 P125—用今天的话讲，他们就是在做“跨界”的事情，因为他们原本的职业并非金融投资，但长期生活和工作在硅谷这个IT环境中，并且有第一手的创办公司和经营公司的经验，这使得他们在风险投资上具备了其他地区投资人所没有的独特眼光。这不仅让他们经常能够打出“本垒打”，而且他们在劝说有经验的管理人才、专业技术人才和销售专家们出来创业时，会特别具有说服力。 P167—硅谷成功的奥秘远不像媒体描述的那样，仅仅是靠气候、好的大学、尊重知识产权等那么简单。硅谷有着很多独一无二的特点，是世界上其他地区所不具备的，这些特点正是硅谷长盛不衰的奥秘。在这些独特之处中，叛逆和对叛逆的宽容、多元文化以及拒绝平庸是硅谷最根本也是最突出的特征。 P178—工程师的五个等级： 第五等：能够独立设计和实现一项功能的人 第四等：需要有产品头脑，也就是说他们在做一件事之前，要知道所做出来的东西是否有用、易用，是否便于维护，是否性能稳定等等 第三等：可以做出行业里最好的产品。他们与第四等工程师有着质的差别，这不仅反映在技术水平、对市场的了解、对用户心理的了解以及对组织能力等诸方面，而且也反映在悟性的差异上。 第二等：那些能给世界带来惊喜的人，比如实现第一台实用化个人电脑的沃兹尼亚克、DSL之父约翰.西奥菲、iPhone和Google Glass的总设计师等。他们与第三四五等工程的差别在于其工作的原创性以及对世界的影响力。 第一等：开创一个全新行业的人，历史上有爱迪生、特斯拉、福特，二战后有保时捷博士、本田宗一郎和硅谷的诺伊斯等人。这些工程师不仅在技术和产品等各个方向上和第二等的工程师有了质的差别，而且在经验和管理上也是好手，他们通常也是企业家，并通过自己的产品改变了世界。 P200—做成伟大的事业，不是一两个人能办到的，需要很多人相互合作，共同努力，因此在企业中人和人之间的关系就不能再是那种简单的雇佣和被雇佣关系，或者层级分明的上下属关系，而是建立在现代商业制度基础上的契约关系。参与一项事业的所有人，不论职级的高低，资历深浅，都是为了一个共同的目的聚集到一起，他们之间彼此通过一种契约将利益捆绑在一起。 P219—比如在互联网2.0之前，再有名的记者都必须隶属于一个报社或者电视台，因为这些媒体公司不仅拥有生产资料（比如办公室和专业器材），而且还拥有读者群，这就构成了一个平台，记者必须隶属于一个媒体平台才能发挥自己的价值。在互联网出现之前，谁拥有了平台，谁就可以聚集各种人才来为自己做事情。那时的企业家非常看中对生产资料和市场渠道的拥有权。思维的形成需要时间，摆脱对一种思维的依赖同样需要时间。如今已是信息时代，很多人也言必称信息时代，但思维和行为方式依然难以摆脱工业时代形成的拥有生产资料的那种优越感。比如很多地方政府在创办科技园时以提供免费场地作为吸引人才的诱饵，骨子里便还是认定场地这种生产资料在经营活动中会起决定性作用。 P233—对比V-2和土星五号，可以看出机械思维和控制论思维两种方法论的差异，前者是对未来做一种尽可能确定的预测，后者则是根据变化不断调整。 P243—1966年，德鲁克出版了《卓有成效的管理者》一书，他在书中指出，在知识社会中，每一个知识工作者本身就是一个自觉的自我管理者，因此对于他们不能采用，也不需要采用过去那种简单的自上而下的人事管理方式，而要改成任务导向的契约式管理方式。 P250—系统论的另一个重要原理就是：封闭的系统永远朝着熵增加（也就是越来越无序）的方向发展，一定会越变越糟糕，而一个开放的系统会引入负熵，才有可能让系统通过与外界的交换变得更加有序，也就是朝着越来越好的方向发展。硅谷地区就是这样一个开放的系统，它不断从世界各地引入新的人才，不断地丰富本已很多元的文化，才能在整体上蒸蒸日上。相反，一个封闭的社会，不论一开始起点多么高，要是关起门来发展，最终那里的人会变得同质化，整个社会也就会变得死气沉沉。 读后感本书书名副标题是“《浪潮之巅》续集”，也就说明了是沿着《浪潮之巅》这本书来展开的。这本书更多得是对《浪潮之巅》的一个延续与总结。看完全书，我将它分成两个部分： 前六章：对于硅谷起源与发展做了一个总结 后两章：对比了工业时代与信息时代的科学基础异同，以此来进一步说明硅谷繁荣的深层次原因 由于前六章与《浪潮之巅》的联系较多，有些内容也都可以从吴军博士之前的书中找到，所以我将他们放到一起做一个总结： 在描述硅谷起源时，吴军博士介绍了硅谷发展的“天时地利人和”： 天时：IBM在计算机技术刚起步时在西海岸设立了研发中心 地利：在全世界气候最好的湾区竟然还有几十平方公里的空地，可以提供给后来的科技公司使用 人和：诺贝尔奖获得者肖克利靠自己的名气吸引了当时全世界最出色的技术人才来到湾区创业，并且由于自己不善管理，最终这些人才都出去创办了新的公司，并且不断有人再“叛逃”，继续创办新的公司，也形成了硅谷地区“不忠诚”的风尚 所以吴军博士认为，硅谷的繁荣有其偶然性，并且有不可复制性，因为想要凑到相类似的“天时地利人和”可谓是不可能完成的任务。 在揭示硅谷繁荣的奥秘时，吴军博士讨论了以下几个原因： 叛逆和宽容：叛逆又分为在公司里和离开后，许多硅谷公司允许员工在公司里有自己的项目，并且在做起来之后会给予资金的支持；离开公司以后，相关的竞业协议也是属于君子协定，即只要不是源代码级别的拷贝，就不会有太大的问题。 多元文化：旧金山湾区最先殖民的是西班牙人，后来发现了金矿之后，来自世界各地的人都来这里淘金，他们带来的多元文化形成了湾区与美国其他地方文化的不同。 拒绝平庸：拒绝平庸与湾区高昂的生活成本有着关系，由于生活成本很高，倒逼着湾区的企业和人们不断去做最好的东西，而那些被淘汰下来的公司慢慢死去，被淘汰的人们离开这里，但是又有不断的新鲜血液补充进来，形成了一个正向反馈。 宽容失败：由于硅谷地区的公司都是从无到有创建起来的，而这也就意味了高风险，因此人们也知道做一件新的事情失败的几率很高，甚至很多公司项目一开始就是抱着“试错”的态度的。 工程师文化：工程师在美国的社会地位高，薪水也很高，并且工程师们都喜欢自己动手和动脑做一些事情。 不迷信权威：硅谷很多公司的创始人或者员工都存在“跨界”现象，即现在所从事的职业跟当初上学的时候没有关系，并且也崇尚“talk is cheap,show me the code”这样的“重实不重名”的文化。 扁平式管理：员工与公司之间不再是简单的雇佣关系，而是为了共同目标而走到一起的契约关系，公司里面员工的层级很少，工程师往往也能参与到产品的设计过程。 世界情怀：硅谷很多公司的创始人都是理想主义者，怀揣着创造产品并且改变世界的情怀。 上面简单的介绍了前六章的内容，下面要讲的是我认为本书最精华的两章。吴军博士阐述了工业时代与信息时代的科学基础，以此来说明几乎没有经历过工业时代的硅谷地区，如何从一开始就运用信息时代的三论来不断保障自己的发展。在看这一部分的时候，对吴军博士用信息时代的“三论”（控制论，信息论，系统论）的观点来解释硅谷，觉得很奇妙，也佩服吴军博士对于事物本质的探索与追求。有了吴军博士的启发，在这里我也想试着说一下我认为“三论”对于个人，在这个信息时代，也有着很重要的意义： 控制论：以前的时候，老师经常会说要给自己的未来做计划，大到5-10年，小到几个月。这样的“大计划”在信息时代，已经不是很适合了。因为社会的变化太快，很多的计划确实已经赶不上变化。对于个人来说，在这样一个时代里面，可以做些什么呢？对于我来说，工作之后转变很大的一个方面是，在学习的过程中，如何不断得给自己定一些小的目标，而不是那些宏伟的计划，让自己去实现。在实现了小的目标后，根据成果再不断去调整自己的期望与节奏。而且在学习过程中，能否持续让自己处于一个正向反馈的状态也是很重要，例如阶段性能完成的目标是否能给自己带来一种在进步的感觉，正是这种正向的感觉，可以增加学习过程当中的自信心，也更能够根据自身的情况制定下一个阶段的目标。 信息论：信息时代里，由于科技与互联网技术的发展，人与人的关系可以从小范围的网络发展到更大的，彼此连接更加复杂的网络，而更大更复杂的网络也意味着更多的信息流动。对于个人来说，接触到更多类型的人，并且从这些人中获取更多元化的信息，可以增加我们的见识，当然也可以锻炼我们对于世界上各种事情的宽容能力。人只有在接触到更多信息之后，才有可能发现更大的世界，也避免让自己陷入狭隘的思维。就跟硅谷的公司一样，在接触了更多的信息之后，他们做出来的产品就是面向于世界的，而不会是纠结于某一个地区一些小的细节去实现。这样子，也会让公司更聚焦得去完成产品的设计与研发。 系统论：对于一个封闭的系统，熵总是朝着不断增大的方向（也就是越来越无序）发展，而只有引入负熵，也就是外来的东西，才有可能让这个系统朝着好的方向发展。对于个人来说，就是怎么样让自己对于外面的世界充满好奇心，并且去了解生活中一些奇妙的东西。人们对于新东西会有一种本能的好奇，但同时，人们又会去警惕新的东西，因为不知道这些东西会带来什么，好的，或者是不好的。如果克服不了这层恐惧心理，那人们与生俱来的好奇心可能就会慢慢失去，然后就陷于无聊之中，再也没有什么东西能刺激我们的神经。对于我来说，我会在工作之余，尽量出去走走，探寻一个城市的角角落落;或者拥有长假时，出去旅行，去看一些不一样的东西，以此保持自己对于未知世界的好奇以及探索的兴趣。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"《思考，快与慢》读书笔记","date":"2016-01-16T12:54:23.000Z","path":"2016/01/16/20160116-thinking-fast-and-slow-reading-notes/","text":"第一部分：系统1,系统2摘录 P9—系统1和系统2的分工非常高效：代价最小，效果最好。通常情况下，这种分工很有效，因为系统1很善于完成自己的本职工作：它在熟悉情境中采取的模式是精确的，所作出的短期预测是准确的，遇到挑战时做出的第一反应也是迅速且基本恰当的。然而，系统1存在成见，在很多特定的情况下，这一系统易犯系统性错误。你会发现这个系统有时候会将原本较难的问题作简单化处理，对于逻辑学和统计学问题，它几乎一无所知。系统1还有一个更大的局限，即我们无法关闭它。如果看到屏幕上显示一个你认识的单词，你就能读出这个词。 P11—你选择相信测量的结果，但无法控制住系统1带给你的直观感受，即使你知道这两条线长度相同，但是仍然无法把它们视为等长的线。想要消除这种错觉，唯一能做的就是当你再看到两条平行线，并且线的两端有朝向不同方向的箭头时，必须学会怀疑自己的感觉。 P31—测试者发现，注意力训练不仅提升了这些孩子的执行控制能力，而且他们在智力测验中的笔试成绩也提高了，并且这种提升的状态可以维持几个月不变。同一小组所作的其他研究确认了参与了注意力控制的具体原因，表明家长的教育方法也会影响这种能力，研究还证明了，儿童控制其注意力的能力和控制其情感的能力之间有着紧密的联系。 P35—苏格兰哲学家大卫.休谟将联想的原则缩减为三个：相似醒、时空相接以及因果关系。 P37—概念运动效应：在一项实验中，心理学家约翰.巴奇和他的同事们让纽约大学的数位学生从一个包含5个单词的词组中（例如“发现、他、它、黄色的、马上”）挑出4个单词来重组句子。其中一个小组的学生重组的句子中有一半都含有与老年人相关的词汇，例如佛罗里达、健忘的、秃顶的、灰白的或者满脸皱纹的。当他们完成这项任务时，又被叫到大厅另一头的办公室里去参加另一个实验。从大厅的一头走到另一头是这次实验的关键所在。研究者悄悄测量了他们所用的时间。正如巴奇预料的那样，那些以老年为主题造句子的年轻人比其他人走得要慢很多。这个实验后来成了经典案例。这个效应包括信息启动的两个阶段。第一，尽管没有人提过“老年”这个词，但上述那组词令人想到了年迈；第二，这些想法催生了一种行为，即缓慢行走，这个行为与老年人相关。所有这一切的发生都是无意识的。 P39—比如说，我们投票不应受到投票地点的影响，但事实上这个因素却实实在在影响了投票结果。一项关于2000年亚利桑那州选区投票模式的研究表明，当投票站设在某个学校时，加大教育投入力度的议案的支持率就会比投票站设在附近其它地方的要高。 P40—在一个专制国家中，到处挂着领袖的肖像不仅能向你传达“老大哥在看着你”的感觉，还会使你逐渐丧失自主的思想和独立的行为能力。 P41—我用一个关于启动效应的完美展示案例来结束上面的阐述，这个案例实在英国一所大学一间办公室的茶水间进行的。多年来，这间办公室的职员一直都是自掏腰包买茶或咖啡，他们把没被茶水和咖啡的建议价格写下来贴到墙上，上班时每次去接茶水或者咖啡时都会把相应的费用投到一个“诚实盒”里。某一天，有人在价格表的上方贴了张横条，上面既没有什么警告，也没作什么解释。在接下来的10周时间里，每周横条都贴有一张新的图片，图片上要么是一些花，要么是一双眼睛，好像盯着看着图片的人。没有人对这些新装饰发表过什么评论，但“诚实盒”里的钱却有了明显变化，贴“眼睛图片”的时候比贴“鲜花图片”的时候能收到更多的钱。 P46—任何能使联想机制运行更轻松、更顺利的事物都会使我们心生偏见。想让人们相信谬误有个可靠的方法，那就是不断重复，因为人们很难对熟悉感和真相加以区别。权威机构和营销商都深谙这个事实。 P49—研究人员召集了40名普林斯顿大学的学生来做这个认知反应测试，其中有一半问卷使用的是浅灰色的小字。拿到这部分问卷的学生可以辨认出上面是些什么字，但这样的字体会导致他们认知紧张。测试结果清楚地表明：当问卷上的字体清晰时，90%的学生至少会犯一个错误；但当字体勉强能够辨认时，他们的错误率却降到了35%。是的，你没有看错:字体模糊不清时，学生表现更好。这是因为，无论认知紧张是由什么原因造成的，它都更有可能激发系统2来抑制系统1所给出的直接性答案。 P51—曝光效应：重复曝光的结果有益于机体适应其所处的有生命和无生命的环境。这一效应能使机体鉴别出安全的物品和栖息地，是最为原始的社会性依附的基础。因此，重复曝光构成了社会组织和社会整合的基础，而社会组织和社会整合又是心理稳定与社会稳定的基础。 P53—这些发现进一步证实，好心情、直觉、创造力、轻信以及对系统1不断增强的依赖性形成了一个关联群集。悲伤、警觉、怀疑、分析方法以及不断增强的努力程度等因素之间也是相互联系的。好心情使系统2放松对行为的控制：当人们心情好时，直觉和创造力会增强，但也会放松警惕，易犯逻辑性错误，这种关联与曝光效应一样，在生理上也讲得通。好心情是事情进展顺利的信号，周围的环境是安全的，卸下防备并没有什么影响；坏心情则说明事情进展不那么顺利，有可能存在威胁，必须保持警觉。认知放松与愉快的感觉互为因果。 P61—因果性直觉的特点是本书一再出现的主题，因为人们总是很不恰当地将因果性思考用于需要统计论证的情景中。统计性思维总是根据事物的不同类别和总体性质得出个案的结论。可惜的是，系统1并不具备这种推理能力；而系统2通过学习可以进行统计性思考，但几乎没有人接受过必要的相关训练。 P68—群体智慧出现的条件之一：然而，只有在每个人的观察相互独立，每个人所犯错误之间不相关联的情况下，降低错误率的奇迹才能出现。如果观察者持有相同偏见，就算将他们的判断汇总起来也难以降低错误率。 P83—人类的思维偏向于对复杂问题进行简单化处理：思维的发散性可以使懒惰的系统2摆脱很多繁重的工作，快速找到难题的答案。“启发式问题”相对于“目标问题”更容易让人产生联想并作出回答。你对海豚和金融骗子的感觉，你现在的心情，你对自己看好的竞选人政治能力的印象，或者总统现在的立场等，都会立即呈现在你的脑海中。启发式问题给每个有难度的目标问题都准备了一个现成的答案。 总结系统1是我们生活中遇到事情最快反应过来的那部分，可以说那是习惯：不管是习惯动作，还是习惯思维。而系统1的养成又受很多方面的影响： 对于事物的熟悉程度，熟悉度高，系统1很容易占上风，从而可能导致错误估计； 心情的好坏，好心情也容易导致系统1占优势，从而使自己卸下防备； 周边环境的影响：重复性宣传、引导性提示、相关性联想等等 第二部分：启发法与偏见摘录 P106—锚定效应：若没有提到锚定问题，这些对环境都很敏感的探索馆参观者会说他们愿意拿出的钱平均为64美金。当锚定金额只有5美元时，平均捐款则是20美元。当锚定金额达到400美元时，人们的捐款平均数就达到了143美元。 P113—可得性偏见：亲身经历、生动的图片和鲜活的例子比发生在别人身上的事、单纯的文字或者是统计数据更容易让人回想起来。一个与你相关的判断错误会主见削弱你对司法体系的信任度，其影响成都比你在报纸上读到此类事情的影响更深。。。。。时刻对偏见保持警惕是件累人的事–但由此便可避免一个代价高昂的错误，因为付出努力也是值得的。 P114—可得性偏见会影响我们对自己或他人的看法：自我评估是由事件呈现在脑海中的轻松度来衡量的。轻松地想起某件事的体验比想起事情的数量更重要。 P120—这其中的道理很明显：对死亡原因的估测因媒体报道而有所改变。报道往往偏向新鲜和尖锐的事。媒体不仅影响了公众的兴趣，也受到公众兴趣的影响。编辑不可能忽略公众的需求，就对某些话题和观点进行大量报道。不同寻常的事件（比如腐肉中毒）会格外引人注意，人们常会低估此类事件的发生概率。我们脑海中的世界并不是真实世界的准确反映；我们对事件发生频率的估测也会受到自己接触这些信息和频率与个人情感强烈程度等因素的影响。 Chapter17—所有表现都会回归平均值：这个现象在篮球场上也适用，球员能否投中下一个球跟他投上一个球是独立的，尽管篮球评论里面都有说某个球星的“手感火热”，但从整体的统计数据来看，关键时刻投中球的概率是一个球员的平均水平表现，而我们又会对那些关键时刻的进球有更深的印象，所以也就出现了可得性偏见。 P175—信息不足时，极端预测和预测罕见事情的事情的意愿都源于系统1。联想机制会很自然地将极端预测和作出这些极端预测所依据的可察觉信息极端性匹配在一起–这也正是替代的运行机制。而且系统1形成过于自信的判断也是正常的，因为自信是由你根据可得信息提炼出来的最合理故事的连贯程度决定的，这一点我们都明白。但要注意：你的直觉会产生极端预测，而你也很容易对这种极端信心满满。 总结这部分的锚定效应、可得性偏见、回归平均值效应、信息不足时系统1的联想机制都可以被用来解释一些生活中的现象，当然也可以运用这些知识来做一些引导： 锚定效应可以运用于需要定高标准的地方，例如：捐款、公司业绩的预测等 可得性偏见可以运用于舆论引导，但是舆论引导是一件很难把握的事情，如果是被居心叵测的人或机构进行了错误地引导，很容易带偏大众的想法。 第三部分：过度自信与决策错误摘录 P182—实验人员选了一个尚无定论的话题，比如说死刑，之后他们仔细测试了受试者的态度。接下来，受试者们会看见或听见一则颇具说明力的信息，这则信息对所选话题持或赞同或否定的态度。然后实验人员再次测试受试者的态度，受试者往往倾向于他们看到或听到的那个观点。最后受试者要说出自己在实验前的观点。这项任务也很难。受试者被问到之前的观点时，说的往往就是现在的观点，这便体现了替代理论，而且很多人都无法相信他们之前的观点与现在的不同。 P197—不幸的是，光有评估公司商业前景的技能还不足以确保在股票交易中取得成功，因为股票交易中的关键问题关于该公司的这些信息是否已经包括在股价里了。交易者显然缺少回答这一关键问题的能力，但他们貌似又对自己的无知一无所知。 P207—他们的论述有理有据，但却与一个心理学事实背道而驰：对大多数人来说，错误的原因最重要。由于运算法导致婴儿死亡的案例比人为因素造成的悲剧更让人感到悲痛。这种情感强烈程度已经上升到道德取向的层面了。 P216—遵从眼见即为事实原则的大脑可通过忽略自己所不知道的事而变得过于自信。因此，许多人容易对没有事实根据的直觉怀有高度的自信也就不足为奇了。我和克莱茵最终就一个重要的原则达成了共识：人们对直觉的自信心不能作为他们判断的有效性的可靠指标。 P216—如何培养有效性直觉： 一个可预测的、有规律可循的环境。 一次通过长期训练学习这些规律的机会。 P234—竞争忽视： 我们将注意力集中在目标上，锚定我们的计划，却忽视了相关的基础比率，导致规划谬误。 我们只关注自己想做的和能做的，却忽视了他人的计划和技能。 在解读过去和预测未来时，我们强调了技能的因果角色，却忽视了运气的影响。因此，我们产生了“控制错觉”。 我们只重视自己已知的，却忽视自己未知的，因此我们对自己的信息过度自信。 总结人们对于自己的所见所想很多时候都会有很强的自信心，而这个自信心是不管自己在这些方面是否有很大把握的。既然人的天性是这样的，那除了在下结论或做决定前怀疑下自己之外，如何培养个人的有效性直觉，就显得很重要了，本章P216就讨论如何培养有效性直觉的方式。 第四部分：选择与风险摘录 P256—第三个原则是损失厌恶。当我们对盈亏进行直接比较或权衡时，亏似乎比盈影响更大。积极和消极的期盼或体验之间的力量不对称状况由来已久，将各种威胁当成“危”而不是“机”的有机体的存活和繁殖的概率更大。 P268—上述这些市场交易与R教授不情愿出售自己的葡萄酒有什么区别？就像那些持有美国橄榄球超级杯大赛门票的人，即便有人出一个非常高的价格也不愿转让这种做法又有什么区别？这一区别特征就是，商家要卖给你的鞋和你从预算中拿出来的买鞋钱都是用来“作交换”的。人们想用它们来交易以换取其他商品。其他商品比如葡萄酒和橄榄球超级杯大赛，那是拿来“使用”的，或者说都是用于消费或享受的。你的闲暇时光和收入也都不是用来交换。 P275—有些实验人员描述道，生气的面孔在众多快乐的面孔中会“凸显出来”，但快乐的面孔在众多生气的面孔中却不会很突出。人类的大脑和其他动物的大脑都包含一种机制，这种机制总会优先考虑不好的消息。将察觉掠食者所需的时间减少百分之一秒，通过这种做法，提高了动物的生存概率，使其可以繁衍生息。系统1的自动运行便体现了这种进化史。 P276—其他学者在一篇题为“坏消息比好消息强”的文章中将原因总结为以下几点：“负面情绪，不负责任责任的父母和糟糕的反馈比好的情况更具影响力，且人们处理坏消息时比处理好消息更彻底，我们会更在意避开负面的自我定义，而不是追求正面的自我定义，不好的印象和不好的模式比好的情况更容易形成，且不易消失。” P296—对决策制定过程中情感和生动性作用的最新研究影响了我对决策权重的看法。过高权衡不太可能的结果是系统1的特点，我们对此已经很熟悉了。情感和生动性会影响顺畅性、可得性以及对概率的判断--因此也就解释了人们为什么过分关注那些没有被自己忽略掉的罕见事件。 P332—我们可以看到，理性通常会受到更广泛、更综合的框架的限制，而且联合评估显然比单一评估更广泛。当然，当能控制你所看到的人对你的选择有既定兴趣时，你应该在联合评估时谨慎些。售货员很快就意识到改变购物环境能影响顾客的偏好。除了故意的改变外，你可以设想判断时用对比的方法(一定会包括系统2)会比单一评估更稳定，单一评估常会反映出系统1的情绪反应强度。 P339—在前景理论中，根据结果的好坏，我们对打赌还是确定的事的选择也会不同。当结果是正面的时候，决策制定者更愿意选择确定的事（他们是风险规避者）；当结果都是负面的时候，他们更愿意拒绝确定的事，愿意赌一把（他们会冒险）。 总结这部分描写了人们对于正面和负面、好和坏、快乐与不快乐、损失与收益等这些对立面的印象与选择： 坏和不快乐会给人们留下更深的印象，且不容易消失；而好和快乐则是“短暂”和“易逝”的。 人们对于正面的结果偏向于风险规避；而负面的结果则是会选择冒险（风险追求），这是因为人们对于损失的厌恶。 第五部分：两个自我摘录 P365—经验自我的幸福感也会随着收入增加，但超过那个标准后，也就不会再提升了。。。。其合理的解释为，更高的收入会削弱人们享受生活中小乐趣的能力。 P394—因此，未能理解回归效应会导致人们高估惩罚的有效性，低估奖赏的有效性。无论是在社会交往中，还是在训练中，表现得好都会有奖赏，表现得差也都会有惩罚。因此，行为最有可能在惩罚之后得到改进，在奖赏之后变得更坏，这其实就是一种回归现象，其结果就是：人们碰巧因为惩罚他人得到了奖赏，因为奖赏他人得到了惩罚。然而，人们通常不会意识到这种偶然性。事实上，难以掌握回归性主要是因为奖赏与惩罚带来的结果非常明显，因此，这个领域的学者也没有注意到它。 P407—伯努利建议不要通过收益结果来评估前景，而是要通过这些结果的主观价值来评估。某次赌的主观价值也是一种经过权衡后的平均值，但在这里，每种结果的主观价值是通过其发生的可能性来权衡的。为了在这个框架下解释风险规避，伯努利提出主观价值或者说是效用，可用收益的凹函数来表示。例如，在这种函数下，200美元和100美元间效用的不同比1200美元和1100美元间效用的差异更明显。从函数的凹处可以看出，得到800美元的主观价值比得到1000美元的价值的80%要大。因此，效用函数的凹处也就一味着是风险规避，人们会选择肯定能得到800美元，而不是有80%的概率得到1000美元，尽管这两种可能最终得到的钱数一样。 P420—下面两个问题：1.你会接受一个有10%的概率获得95美元，90%的概率损失5美元的赌么？2.有种抽奖有10%的概率赢得100美元，90%的机会什么也得不到，你愿意花5美元参加这种抽奖吗？结果显示：更多人愿意接受问题2这种形式，虽然这两个问题的选项从客观上讲是一致的，但相比于5美元的损失，如果将这5美元当作支付的钱，使得这个冒险更加容易令人接受，而彩票就是这样的。 整体感受通过阅读本书了解到人类思考的一些模式，通过对这些模式的了解，可以对一些商业行为，政府宣传行为作出解释。商业公司或者媒体等机构，往往会利用人类思维模式上的一些弱点，来进行有针对性的推广或引导舆论，让大众跟着自己的节奏走。而因此产生的后果，往往又只有大众自己来承担，所以如果想让自己拥有更强的辨识能力，就需要锻炼自己系统2的能力，遇到需要做结论或做决定的地方，多去怀疑自己一瞬间就能得到的想法，因为这些想法都是由系统1得出的，很可能存在偏差，许多时候，系统2都需要做出一些修订，让最终的想法或行为更加合理，而不至于到犯了错误才反应过来。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"仿Smartisan OS图库快速选择功能","date":"2015-11-24T07:34:42.000Z","path":"2015/11/24/20151124-drag-select-image-summary/","text":"Smartisan OS图库快速选择功能描述使用Smartisan OS的用户应该都知道图库有个快速选择功能，用户在编辑模式下，可以滑动选中图片。这个功能当时发布会时，老罗也拿出来当作亮点功能说的，确实这个功能在使用上手之后，对于批量删除操作，是很赞的。在深入分析这个功能之后，发现里面涉及到很多内容，在此先分解下它的功能细节: 只有横向滑动才会触发快速选择图片模式，为了避免与竖滑滚动操作冲突 一开始滑动时，到第二个位置才会将第一个和第二个位置下的图片一起进行操作（选中或清除），此后都是滑到哪个位置操作到哪个位置（滑动方向没有变化的情况） 如果滑动方向改变了（例如本来的方向是朝着位置不断变大滑，突然转向，朝着位置变小滑，此时认为它滑动方向变化），然后就是对上一个位置进行操作 如果滑动到的位置与上一个位置之差绝对值大于1，则需要对两个位置中间的位置进行操作，如果有转向，则传入的位置参数也会有不同 滑动到屏幕上下边界的时候，视图会自动滚动 可以记录每一次滑动的初始目的，是要进行选中还是清除操作，如果进行的是选中操作，则在滑动过程中遇到已经选中的图片，就不会对它进行清除操作 功能实现下面就针对这个快速选择功能，记录下我的实现过程 第一步:手势操作实现这个功能的第一步就是识别我们手在屏幕上滑动，并且知道实时的位置在哪里。Android自带的GestureDetector类可以帮助我们实现监听手势操作，在初始化时，创建GestureDetector对象: 1gestureDetector = new GestureDetector(this, new FastSelectGestureListener()); FastSelectGestureListener是继承GestureDector.SimpleOnGestureListener，实现手势监听的一个类，并且重写了onDown和onScroll方法，onDown方法在手指落下接触屏幕的时候只调用一个，而onScroll方法是在手指滑动的时候不断调用，直到手指离开屏幕结束此次手势操作。在这两个方法里，也是进行图片操作的具体逻辑。 给recyclerView添加OnItemTouchListener监听，并且在onInterceptTouchEvent方法里，添加手势触摸事情，让系统去接收，具体代码如下: 12345678910gestureDetector.onTouchEvent(e);if (e.getAction() == MotionEvent.ACTION_UP) &#123; dragSelectEnable = false;&#125;if (dragSelectEnable) &#123; recyclerView.stopScroll();&#125;return false; 第二步:找到当前手指触摸位置下的view和position在RecyclerView里，findChildViewUnder方法可以通过坐标来获得View，具体实现如下: 1View view = recyclerView.findChildViewUnder(e.getX(), e.getY()); e是MotionEvent。当null != view情况下，可以通过getChildAdapterPosition()方法获取view在adapter里的position: 1position = recyclerView.getChildAdapterPosition(view); 第三步:具体逻辑实现onDown方法初始化参数每一次手势操作，都需要对于参数进行重新赋值，具体代码如下: 12345678910View view = recyclerView.findChildViewUnder(e.getX(), e.getY());if (null != view) &#123; initialPosition = recyclerView.getChildAdapterPosition(view); lastPosition = initialPosition; selectInitialPositionFlag = true; positionFlag = false; positionTrend = 0;&#125;return super.onDown(e); 只有横向滑动才能激活选择图片操作因为竖向滑动是对recyclerView进行滚动，所以只有横向滑动才能激活快速选择模式，否则不对图片进行操作: 12345678//only horizontal gesture can active drag select image modeif (Math.abs(e1.getX() - e2.getX()) &gt; FAST_SELECT_ACTIVE_X_DISTANCE &amp;&amp; Math.abs(e1.getY() - e2.getY()) &lt; FAST_SELECT_ACTIVE_Y_DISTANCE) &#123; dragSelectEnable = true;&#125; else &#123; if (!dragSelectEnable) return false;&#125; 其中FAST_SELECT_ACTIVE_X_DISTANCE和FAST_SELECT_ACTIVE_Y_DISTANCE分别是激活快速选择模式X轴和Y轴位移的阀值， 每一次转向对于一些参数都要重新赋值由于每一次转向，都需要传入不同的位置参数给performGalleryItemCheck方法，所以需要对参数进行重置: 12345678//positionFlag updates when gesture direction is changedif (((position - lastPosition) &gt; 0 &amp;&amp; positionTrend &lt;= 0) || ((position - lastPosition) &lt; 0 &amp;&amp; positionTrend &gt;= 0)) &#123; positionFlag = !positionFlag; selectOrClearFlag = adapter.getItemSelectedState(lastPosition); positionTrend = position - lastPosition; selectInitialPositionFlag = true;&#125; 进行选择操作一共分为以下三种情况: 当前位置与上一个位置之差绝对值为1 当前位置减去上一个位置大于1 当前位置减去上一个位置小于1 分成三种情况，也就是三种情况分别传入的位置参数都是不同的，具体代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243if (Math.abs(lastPosition - position) == 1) &#123; if (position == initialPosition) &#123; performGalleryItemCheck(initialPosition); &#125; if (positionFlag) &#123; performGalleryItemCheck(position); //check initialPosition only once when everytime starting drag select image if (selectInitialPositionFlag &amp;&amp; Math.abs(position - initialPosition) == 1) &#123; performGalleryItemCheck(initialPosition); selectInitialPositionFlag = false; &#125; &#125; else &#123; performGalleryItemCheck(lastPosition); &#125;&#125; else if ((lastPosition - position) &gt; 1) &#123; if (positionFlag) &#123; for (int i = position; i &lt; lastPosition; i++) &#123; performGalleryItemCheck(i); &#125; &#125; else &#123; for (int i = position + 1; i &lt;= lastPosition; i++) &#123; performGalleryItemCheck(i); &#125; &#125;&#125; else &#123; if (positionFlag) &#123; for (int i = lastPosition + 1; i &lt;= position; i++) &#123; performGalleryItemCheck(i); &#125; &#125; else &#123; for (int i = lastPosition; i &lt; position; i++) &#123; performGalleryItemCheck(i); &#125; &#125;&#125;// update lastPositionlastPosition = position; 添加自动滚动当手势操作在上下边界时，实现自动滚动的进行选择的效果。 RecylerViewAutoScrollHelper类继承了AutoScrollHelper类，传入recyclerView作为这个helper的对象，具体实现代码如下: 1234RecyclerViewAutoScrollHelper helper = new RecyclerViewAutoScrollHelper(recyclerView);recyclerView.setOnTouchListener(helper);helper.setEnabled(true); 在RecyclerViewAutoScrollHelper类里，让recyclerView实现自动滚动，并且控制滚动的速度。 Demo地址具体的代码，已经开源到GitHub，如有兴趣，请通过这个链接查看，谢谢观看。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"爬墙思路总结","date":"2015-11-22T07:27:04.000Z","path":"2015/11/22/20151122-cross-the-GFW/","text":"前言首先，这不是一篇严格意义上的爬墙教程，因为爬墙的方式太多，各种细节也太多，所以本文只是记录其中一种思路，能看到本文的还请包涵。PS：本文的操作是针对MAC OS，并且需要一定的Linux操作指令基础，因为像cd、ls等指令都是基础的Linux指令，在操作过程中都需要用到。 正文第一步:拥有一个VPSVPS介绍VPS是什么？简单来说就是一个远程电脑，你可以通过配置它，实现爬墙的目的。当你在爬墙的时候，这个VPS就是一个中间桥梁的角色，所有你的网络请求，先发向VPS，VPS得到请求后，进行转发，去访问你想要的网络地址；网络上返回的数据也是通过VPS，然后再返回到你的本地电脑上。 如何拥有VPS目前市面上有很多VPS提供商，下面列举几个著名的（我自己没有在用这几个，下面的评价都是网上的信息），至于选择哪个，完全由你决定： Linode:这个特点就是贵，但是服务也稳定，具体价格搜下它的网站就知道了 Digital Ocean:比Linode便宜，但是服务也比较稳定 Bandwagon:在这三个中最便宜，价格亲民，适合新手 Vultr:这个网上有个很详细的教程，这里也贴出来Vultr教程 其它其实还有很多，我自己是跟同学合用一个，当时是同学买的，所以没有操心VPS这部分，哈哈哈 第二步:本地生成ssh公私钥SSH是什么？SSH可以看做是给你的所有网络请求加了一个安全外壳，这样你的所有爬墙访问就不容易被人家破解，毕竟爬墙在sky朝是不被允许的。 如何获取ssh公私钥首先Spotlight里搜索terminal，回车打开terminal，在terminal里输入下面指令: 1cd ~/.ssh 输入指令后会有两种情况: 没有任何提示，则说明ssh公私钥已经存在，此时再输入下面指令: 1ls 这时候看有没有.pub结尾的文件，如果有，执行下面指令: 1cat ~/.ssh/id_rsa.pub 如果.pub前面的名字不是id_rsa，则换成你看到的名字。执行上面指令后，会出现你的公钥，此时复制公钥信息，备用。 如果terminal里面出现包含No such file or directory这句话的提示，说明你还没有创建过ssh公私钥，此时在terminal里面输入下面指令: 1ssh-keygen 有任何提示，一路回车即可，注意看，如果要填写邮箱，可以填上自己的邮箱。不出意外，ssh key已经生成，下面的步骤就跟上面有.pub文件一样了，输入cat ~/.ssh/id_rsa.pub，获得公钥信息，复制备用。 第三步:登陆VPS，将ssh公钥放到VPS上第一步买来的VPS，这时候第一次派上用场了，在买完VPS后，厂商会提供初始登陆的用户名，密码和你的VPS对应的IP地址（有些云服务提供商的VPS服务需要自己开通，比如vultr），这时候还是在terminal里面，输入下面指令: 1ssh username:password@ip username表示你的用户名，password表示你的初始登陆密码，ip表示你的VPS对应的IP地址，指令输完后，按回车，应该是让你再输入一遍初始密码，此时再输入一遍，回车一下，就远程登陆上你的VPS主机了。PS:可能不同VPS提供商的登陆方式有点不同，具体还请看提供商给出的登陆示例 然后第一次登陆，要创建.ssh文件夹，输入以下指令: 1mkdir .ssh 再输入 1vi authorized_keys 创建放置ssh公钥的文件，进入之后，输入i，进入编辑模式，此时输入ssh-rsa+刚才复制的ssh公钥+#，再点击esc退出编辑模式，接着输入:wq对文件进行保存并退出。通过这些步骤之后，公钥已经成功放到VPS上了 第四步:本地配置config文件config文件的作用本地配置好config文件以后，就可以结合刚才VPS上的公钥，通过ssh方式登陆远程VPS了。 如何配置输入以下指令: 1cd ~/.ssh 由于刚才已经创建过ssh公钥了，所以这时候输入上面指令，肯定能进入隐藏的ssh文件夹。再输入: 1ls 看有没有config文件，如果没有，则用以下指令创建: 1touch config 此时再输入: 1pwd 会得到当前目录的路径，复制，打开finder，点击前往-前往文件夹(Go-Go to Folder)，粘帖刚才复制的路径，回车，看到config文件，右击，使用文本文档打开，输入以下内容: 12345Host xxx(随便取个名字，英文最好)User rootPort 22Hostname 102.102.102.102（改成你VPS的IP）IdentityFile ~/.ssh/id_rsa 进行保存后，然后再回到terminal里面，输入: 1ssh xxx(刚才config文件里面的Host后面的内容) 正常来说，这时候你就可以用ssh方式远程登陆你的VPS主机了。 第五步:VPS上配置shadowsocks其实这一步才是真正的开始爬墙的配置，前面的全都是铺垫，但是为了更安全爬，前面的步骤也是需要的。这一步的核心内容，网上有个很不错的教程，我基本上就是按照这个链接里的教程来进行的，在此感谢原作者。 VPS安装shadowsocks刚才已经用ssh方式远程登陆VPS了，如果没有，还是用ssh xxx方式进行登陆。然后执行下面指令: Debian/Ubuntu系统12apt-get install python-pippip install shadowsocks CentOS12yum install python-setuptools &amp;&amp; easy_install pippip install shadowsocks 这样shadowsocks就安装好了。 编写配置文件这个配置文件包含下面一些信息:VPS地址，端口，代理端口，登陆密码等，使用下面指令创建一个json配置文件: 1vi /etc/shadowsocks.json 点击i进入编辑模式，然后输入下面内容: 12345678910&#123; \"server\":\"my_server_ip\", \"server_port\":25, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"mypassword\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false&#125; 上面内容注意以下几点: server后面跟的是你VPS地址 server_port后面是端口，你可以配置多个端口，每个端口配置不一样的密码，这样就可以给多个人使用了 method后面是加密方式，在配置客户端的时候会用到 password后面是你的密码，配置客户端的时候会用到 如果要给多个人使用，则配置文件内容应该是下面的格式: 1234567891011121314 1 &#123; 2 \"server\":\"my_server_ip\", 3 \"local_address\": \"127.0.0.1\", 4 \"local_port\":1080, 5 \"timeout\":300, 6 \"method\":\"aes-256-cfb\", 7 \"fast_open\": false, 8 \"port_password\": 9 &#123;10 \"24\":\"xxx\",11 \"8084\":\"xxx\",12 \"8086\":\"xxx\"13 &#125;14 &#125; 里面的24、8084就是端口，后面是对应的密码。然后:wq进行保存退出。 启动shadowsocks配置文件写好后，输入以下指令启动shadowsocks服务器: 1ssserver -c /etc/shadowsocks.json -d start 后台停止shadowsocks指令: 1ssserver -c /etc/shadowsocks.json -d stop 以便某天可以关闭这个服务。 第六步:MAC上以及手机上安装shadowsocks客户端并配置MAC上shadowsocks客户端配置需要写入ip+远程端口；加密方式选择刚才配置文件中method后面的加密方法，这里是aes-256-cfb；密码就输入刚才配置文件里面password后面的内容。 Android上shadowsocks客户端配置跟MAC上配置基本差不多，把ip、端口、密码和加密方法填入，然后打开，就可以进行全局爬墙啦。 iOS客户端由于iOS系统限制很多，即使配置好shadowsocks客户端，也只能网页爬墙，而不能全局爬墙。","tags":[{"name":"实用技能","slug":"实用技能","permalink":"http://yoursite.com/tags/实用技能/"}]},{"title":"MME_v1.3.4.0_开发个人总结","date":"2015-11-17T12:39:19.000Z","path":"2015/11/17/20151117-v1.3.4.0-dev-summary/","text":"照片按时间分组的实现分析这个版本新加了这样一个功能：照片按照时间进行分组排列，要实现这个功能，则需要让RecyclerView有两个ViewType，下面就来记录下同事实现的思路: 在adapter类里重写getItemViewType方法，并用isParent方法判断类型，返回两个不同的类型:ITEM_VIEW_TYPE_PARENT和ITEM_VIEW_TYPE_CHILD 在onCreateViewHolder方法里，判断viewType，绘制不同xml里的view，然后返回不同的ViewHolder 在onBindViewHolder方法里，根据ViewHolder不同，执行不同的代码逻辑 ItemViewType是通过对SecureAlbummodel用setAdapterType方法进行设置，然后根据不同位置，设置不同的ItemViewType，以便adapter可以根据不同类型生成不同的view 拍照后照片截取部分进行保存这个版本中，因为上下部分由原来的半透明变成不透明，所以需求是：拍照保存的图片大小是用户可见范围，刚开始的思路是:CameraPreview不全屏放置，这样最终效果会将拍照后的照片进行了’拉长’，因为预览的图片被压缩，而拍出来的照片是正常进行保存，但是给用户的感觉是被’拉长了’。而如果想要正常显示，则需要对CameraPreview的PreviewSize进行重新计算，这样是对相机本身的显示比例进行调整，比较复杂。后来想到的方案是: 对于拍照后的图片进行裁剪处理，这里要特别注意的是:由于照片原始尺寸与屏幕尺寸不一致的，所以要对屏幕上需要裁剪的部分根据照片原始尺寸与屏幕尺寸比例进行换算，才是需要裁剪掉的真实大小 然后是对照片进行裁剪（如果有需要同时进行翻转、镜像保存），这里使用了BitmapRegionDecoder这个类的decodeRegion方法，传入参数Rect和BitmapFactory.Options，下面是具体代码实现: 12345678910111213141516171819//当照片是竖向时if (temp.getHeight() &gt; temp.getWidth()) &#123; double targetRatio = (double) temp.getHeight() / (double) OSUtil.getWindowHeight((Activity) mContext); int top = (int) (targetRatio * mContext.getResources().getDimensionPixelSize(R.dimen.camera_actions_height)); int bottom = (int) (temp.getHeight() - targetRatio * mContext.getResources().getDimensionPixelSize(R.dimen.camera_bottom_layout_height)); Rect rect = new Rect(0, top, temp.getWidth(), bottom); croppedImage = cropImage(rect, data);&#125; else &#123; //当照片是横向时 double targetRatio = (double) temp.getWidth() / (double) OSUtil.getWindowHeight((Activity) mContext); int left = (int) (targetRatio * mContext.getResources().getDimensionPixelSize(R.dimen.camera_actions_height)); int right = (int) (temp.getWidth() - targetRatio * mContext.getResources().getDimensionPixelSize(R.dimen.camera_bottom_layout_height)); Rect rect = new Rect(left, 0, right, temp.getHeight()); croppedImage = cropImage(rect, data);&#125; 123456789101112131415161718192021222324252627282930313233343536373839private Bitmap cropImage(Rect rect, byte[] data) &#123; InputStream is; Bitmap croppedImage = null; Bitmap rotatedImage = null; int degree = ExifUtil.getOrientation(data); Matrix m = new Matrix(); m.postRotate(degree); // 前置拍照图像镜像保存 if (CameraController.isFrontFacing(cameraId)) &#123; m.postScale(-1, 1); &#125; try &#123; is = new ByteArrayInputStream(data); BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(is, false); try &#123; croppedImage = decoder.decodeRegion(rect, new BitmapFactory.Options()); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (null != croppedImage) &#123; rotatedImage = Bitmap.createBitmap(croppedImage, 0, 0, croppedImage.getWidth(), croppedImage.getHeight(), m, true); &#125; if (null != rotatedImage &amp;&amp; rotatedImage != croppedImage) &#123; return rotatedImage; &#125; return croppedImage;&#125; Tips如果应用里面有全屏和非全屏的界面，则全屏跳转到非全屏之前就要将statusbar重新显示，否则在非全屏页面绘制结束后，调用显示statusbar代码时会重新进行measure和绘制操作，结果就是在5.0以上系统RealTimePhotoActivity里显示的图片会出现向下移动，这就是页面在重新measure后进行绘制的表现。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"MME_v1.3.2.1+v1.3.3.0_开发个人总结","date":"2015-10-26T06:52:49.000Z","path":"2015/10/26/20151026-mme-v1.3.2.1+v1.3.3.0-dev-summary/","text":"关于网络请求在开发v1.3.2.1版本时，新增了这样一个需求：在某些节日，应用需要从服务端下载对应的启动页(Splash)图片并在特定的时间内显示。具体分到给我的任务是：如果有新图片需要下载的时候，下载下来保存到本地。由于我们的项目网络请求时采用async-http-client开源框架，这个功能自然也会继续沿用这个框架。如果单纯用这个框架进行开发，是很容易实现的，但是我们对于发起的请求加了签名校验这一步骤，不过由于此前版本做图片上传功能时已经做过类似的签名校验，这一部分也没有耽误什么时间。准备工作都做完之后，测试的时候，发现发起请求成功，服务端也有数据返回（这里使用Charles这个神器来进行数据抓包的），但是程序就是没法解析出数据。 下面写出来的是我思考和解决问题的步骤（最终感谢同事的指点）： 重写async-http-client中response handler的生命周期方法，目的是看在生命周期的哪个方法里出现问题（因为有数据返回，但是没有接收到，说明是在response handler处理的过程中出现的问题）： onStart onSuccess onFailure onFinish 打出Log发现，response handler里的onFailure方法执行了，并且statusCode是444 正在我疑惑的时候，去问了后端的同事，他说我这边是不会返回444这个码的，那这个码到底时哪里来的呢？他突然说到之前做过服务端返回数据后，再进行一次签名校验的功能，是不是那里的问题，一打断点，发现还真是这个问题：因为使用了自己封装过的response handler，在服务端返回数据后，又进行了一次签名校验，如果校验不通过，则直接调用onFailure并且返回444状态码 采用async-http-client自带的JsonHttpResponseHandler作为response handler来对返回的json数据进行解析，问题解决 在解决这个问题的过程中，有以下几个关键节点（按开发步骤来）： 发起的网络请求需不需要签名校验 发起的请求服务端有没有接收到 服务端有没有数据返回 客户端接收数据时需不需要签名校验 async-http-client的response handler有4个生命周期，可以用来判断接收的时候在哪里出现问题 async-http-client的设置是:statusCode大于300时，直接报错(执行onFailure方法) 关于动画自定义propertyName在拍照完的照片预览页中有这样一句代码ObjectAnimator.ofFloat(mAnimatingImageView, &quot;animationProgress&quot;, 0.0f, 1.0f)，这里的propertyName是animationProgress，不是一般的alpha、rotation等，在查看了Android文档后(Animating with ObjectAnimator部分)，发现如果要自定义propertyName，则类里必须要有set和get方法，在这句代码里对应的就是setAnimationProgress和getAnimationProgress方法。 透明度、缩放动画后如果进行了透明度、缩放等动画后，没有相反的动画过程，下次再查看相关控件时，会呈现动画结束时的状态，此时如果alpha值是0，虽然控件设置了View.VISIBLE，但还是不可见的，要重新设置alpha值为1.0f。在v1.3.3.0开发过程中，相机页面显示照片数量的角标动画就是一个例子，进入预览页前有一个exit，最后的情况是让该控件alpha值为0，如果此时删除完全部照片，则回到相机页面时不会进入enter动画，这时会导致显示照片数量这个控件不可见，需要设置setAlpha(1.0f)、setScaleX(1.0f)、setScaleY(1.0f)让其正常显示。 View初始状态是“gone”如果一个view的初始状态是gone，执行view.animate().alpha(1.0f).scaleX(1.0f).scaleY(1.0f).setDuration(200)，发现动画不会出现，要使用view.startAnimation(AnimationUtils.loadAnimation(this, R.anim.xxx))动画才会有效果，具体原因还不清楚，等以后搞清楚了再回头来看。 是否一个Activity不可见了就一定会调用onStop？在刚开始接触Android开发时，对于一个Activity的onPause和onStop方法什么时候调用，有以下两个认知： 当前Activity部分不可见时，onPause会调用，例如一个dialog弹出 当前Activity完全不可见时，onPause和onStop会分别调用，例如一个Activity跳转到下一个Activity的场景 在v1.3.2.1版本开发过程中，遇到一个情况，推倒了之前的认知，当Acitivity完全不可见时，onStop不一定调用，这个例外就是：如果跳转过去的Activity主题属性是透明(WindowIsTranslucent=true)，则系统会认为一个类似于dialog的控件附在跳转之前的Activity上，此时虽然前一个Activity不可见了，但只会调用onPause，而不会调用onStop。 照片Exif信息丢失在对拍照后的图片进行压缩保存时，发现保存后图片的Exif信息丢失，这样就会导致在有些机型上，拍照的图片被翻转了，这时候就算读取Exif信息也没用，因为翻转角度信息已经损坏。对于这种情况，有以下两个解决方案： 图片不压缩进行保存 如果图片一定要进行压缩保存，则在写入文件之前，读取Exif信息，如果有翻转角度信息的，对bitmap翻转之后再进行保存","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"MME_v1.3.1+v1.3.2_开发个人总结","date":"2015-09-13T05:53:33.000Z","path":"2015/09/13/20150928-mme-v1.3.1+2-dev-summary/","text":"Android5.0相关点按水波纹效果的属性设置Android5.0系统以后，为了让数字世界更加贴近于真实的物理世界，在点击控件时，可以设置水波纹效果，这个动画被认为是数字世界对物理世界的还原与致敬。对于程序来说，只要给控件设置下面两句属性，就可以有点击水波纹效果： 水波纹效果会超过控件的边界：android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot; 水波纹效果在控件边界里面：android:background=&quot;?android:attr/selectableItemBackground&quot; 如果直接使用第一种，在5.0以上的系统可以运行，但是5.0以下系统因为没有这个属性，所以程序会出现崩溃，刚开始的解决方案是新建values-v21的资源文件夹，在里面的styles用第一种属性；在values里的styles用第二种属性，这样就可以解决兼容的问题。后来发现一种不用设置两种属性的方式，直接在属性里面设置android:background=&quot;?attr/selectableItemBackgroundBorderless，这句代码的意思是：如果控件背景属性支持Borderless的，就用Borderless，如果没有，则自动进行兼容。 Snackbar出现时控件上移效果分析在研究了极简笔记Snackbar相关的代码后，发现CoordinatorLayout+FloatingActionButton+Snackbar三个在一起，可以达到Snackbar出现时FloatingActionButton上移，Snackbar消失后FloatingActionButton下移回到原位置的效果，这个效果依赖于5.0系统在源码上实现了FloatingActionButton对Snackbar的状态的监听。而对于我们自己定义的控件，则需要自己去实现这个监听。 方案重写Snackbar类，主体保持与系统源码相同，只增加一个静态抽象类Callback，并且在Snackbar出现后以及消失后实现该抽象类的两个方法： onShown onDismissed然后在创建Snackbar的时候，加入setCallback(Snackbar.Callback callback)方法，并在onShown()和onDismissed()里实现具体的逻辑。示例代码 123456789101112131415Snackbar.make(photoViewerActions, R.string.hint_import_success, Snackbar.LENGTH_SHORT) .setCallback(new Snackbar.Callback() &#123; @Override public void onDismissed(Snackbar snackbar, int event) &#123; super.onDismissed(snackbar, event); ObjectAnimator.ofFloat(photoViewerActions, \"translationY\", 0).setDuration(300).start(); &#125; @Override public void onShown(Snackbar snackbar) &#123; super.onShown(snackbar); ObjectAnimator.ofFloat(photoViewerActions, \"translationY\", -(float)snackbar.getView().getHeight()).setDuration(300).start(); &#125; &#125;).show(); 定制Snackbar除了上面一条Snackbar出现控件上移，Snackbar在UI上也可以进行定制，定制是在SnackbarLayout这个内部类里实现，并且Snackbar的布局文件也有两个，一个是没有撤销键时的样式，另一个是有撤销键时的样式，原生组件这两个布局文件名字分别是： layout_snackbar.xml–无撤销键 layout_snackbar_include.xml–有撤销键 Toolbar使用方法Toolbar作为5.0以后出现的一个控件，支持很多自定义的效果，是ActionBar一个很好的代替，下面就来介绍下它的一般使用步骤： 单独创建一个toolbar的layout，在需要使用的时候对其进行引用：&lt;include layout=&quot;@layout/toolbar&quot;/&gt;。在toolbar的layout里，可以设置它的一些属性 在BaseActivity里，需要有方法可以判断是否需要toolbar这个控件，也需要有方法可以获取到toolbar，以便于在具体Activity里可以重新设置toolbar的样式：background、TitleTextColor等 关于toolbar一些基本属性的介绍，可以参考：Android 5.x Theme 与 ToolBar 实战 各种类和接口使用分析Adapter加载机制注意点一实例化结束后，会先执行getCount()方法，当getCount()方法返回的值不为0时，会继续执行getView()方法；若getCount()返回的值是0，则不会再继续执行getView()方法。 注意点二在V1.3.1版本以前，会出现点击选择图片闪烁的问题，刚开始都以为是Adapter的问题，在跟许可探讨了这个问题之后，发现可能是UniversalImageLoader这个第三方开源库自己的bug，因为许可之前在使用该开源库时也有过点按闪烁的问题。 在之前解决该问题时，尝试过重新写了一个Adapter，也还是有闪烁问题，共同的一个现象就是，在点按选择照片出现闪烁的时候，getCount()和getView()方法都会明显比不闪烁的时候执行更多的次数，说明Adapter在重复进行刷新。 Handler采用弱引用方式（WeakReference）分析简单来说，之前都是用内部类（包括匿名类）的方式创建Handler，用这种方式Handler会隐式地持有一个外部类对象（通常是Activity对象）。在系统进行耗时的网络请求时，Activity被关闭，但这时候线程会继续持有对Handler的引用，而Handler又会持有对Activity的引用，导致Activity无法被系统正常回收，造成内存泄漏，进而会导致OOM（内存溢出）。 方案采用静态类+弱引用的方式（因为静态类不再持有对外部类的引用，Activity被关闭时，系统可以正常收回；而对于Handler无法操作Activity中对象的问题，采用弱引用的方式解决，而弱引用不会影响系统对Activity的收回） 示例代码123456789101112131415161718192021222324252627282930private static class AppUpdaterHandler extends Handler &#123; private final WeakReference&lt;SettingsActivity&gt; mActivityWeakReference; //构造函数 public AppUpdaterHandler(SettingsActivity activity) &#123; mActivityWeakReference = new WeakReference&lt;SettingsActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; //弱引用当前Activity SettingsActivity activity = mActivityWeakReference.get(); if (activity == null) &#123; return; &#125; switch (msg.what) &#123; case ZConstants.ON_APPS_INFO: &#123; activity.onAppsInfo((JSONObject) msg.obj); break; &#125; case ZConstants.ON_ACTION: &#123; ToastUtil.showToast(activity, activity.getString(R.string.checking_new_version), Toast.LENGTH_SHORT); break; &#125; &#125; &#125; &#125; 注意在Activity初始化时不要忘记实例化Handler对象，详细的解释请参考Android中使用Handler造成内存泄露的分析和解决 Fragment+FragmentPagerAdapter两者之间如何通信123456789public Fragment getItem(int arg0) &#123; final Bundle bundle = new Bundle(); bundle.putInt(SplashFragment.EXTRA_POSITION, arg0 + 1); final SplashFragment fragment = new SplashFragment(); fragment.setArguments(bundle); return fragment;&#125; 在FragmentPagerAdapter（或者它的子类）里重写getItem()方法，用Bundle类将当前的position存起来，再用fragment.setArguments(bundle)方法将当前位置信息传给fragment，在Fragment（或者它的子类）里，用getArguments()方法取得当前的位置，再将View与位置一一对应起来进行设置。 Fragment里的onCreateView与onViewCreated onCreateView一般只用于LayoutInflater.inflate去初始化一个页 onViewCreated顾名思义是当View加载完成之后，马上执行，确定View里面具体放置一些什么控件 自定义WechatCallback接口分析微信分享接收回调是用了WXEntryActivity这个类，并给这个活动设置了透明主题。这个版本中引入了Snackbar，而Snackbar的绘制机制是会找一个父视图，如果没有这个父视图，则会创建不成功。所以在透明主题下，微信回调使用Snackbar出现不会显示的问题。 方案 自定义一个WechatCallback接口，在WXEntryActivity里实现该接口对应的四个方法： void onShareSuccess(int statusCode, int result) void onShareCancel(int statusCode, int result) void onShareDenied(int statusCode, int result) void onShareDefaultStatus(int statusCode, int result) 在目标页面setCallback，这个回调最终是用弱引用的方式获得 在目标页面接收回调，并进行相应的处理 动画点击Flash展开的动画(直接代码设置)逻辑 点击Flash按钮展开选项，可以用setPivotX方法设置展开的位置 点击Flash按钮关闭选项，这个时候Flash按键本身有一个旋转动画： 离Flash按钮近的转到远的，旋转角度是顺时针 其它情况是逆时针 主要代码整个动画主代码1234567891011121314151617181920212223242526272829303132333435private void playFlashOptionsAnimatorSet(final boolean isIn) &#123; mFlashInAnimation = true; ObjectAnimator flashSettingAnim = getFlashOptionsAnimator(isIn); AnimatorSet animatorSet = new AnimatorSet(); if (isIn) &#123; //只进行展开动画 animatorSet.play(flashSettingAnim); animatorSet.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); mFlashInAnimation = false; &#125; &#125;); &#125; else &#123; ObjectAnimator flashAnim = getFlashChangeAnimator(); //展开动画和旋转动画一起执行 animatorSet.play(flashSettingAnim).with(flashAnim); animatorSet.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); mFlashInAnimation = false; mFlashLastStatus = mFlashCurrentStatus; mFlashSetting.setVisibility(View.INVISIBLE); updateFlashIcon(mFlashCurrentStatus); &#125; &#125;); &#125; animatorSet.setDuration(200); animatorSet.start();&#125; 展开关闭动画123456789101112 private ObjectAnimator getFlashOptionsAnimator(boolean isIn) &#123; ObjectAnimator scaleX; if (isIn) &#123; mFlashSetting.setVisibility(View.VISIBLE); scaleX = ObjectAnimator.ofFloat(mFlashSetting, \"scaleX\", 0.0f, 1.0f); &#125; else &#123; scaleX = ObjectAnimator.ofFloat(mFlashSetting, \"scaleX\", 1.0f, 0.0f); &#125;//设置展开的X轴位置 mFlashSetting.setPivotX(getResources().getDimensionPixelSize(R.dimen.camera_flash_anim_pivot_x)); return scaleX; &#125; 旋转动画1234567891011private ObjectAnimator getFlashChangeAnimator() &#123; ObjectAnimator rotate = null; if (mFlashCurrentStatus &gt; mFlashLastStatus) &#123; rotate = ObjectAnimator.ofFloat(mFlash, \"rotation\", 0f, 360f); &#125; else if (mFlashCurrentStatus &lt;= mFlashLastStatus) &#123; rotate = ObjectAnimator.ofFloat(mFlash, \"rotation\", 360f, 0f); &#125; return rotate; &#125; 5.0系统以下点击按钮透明度变化（引入xml文件属性生成）因为5.0以下系统不支持点击按钮水波纹效果，所以设计成按钮透明度变化来产生点按效果，与上面完全代码实现动画效果不同的是，在完成这个效果时，将属性写在了xml文件里。具体代码如下：123456789101112131415161718192021222324252627public static boolean onAlphaViewTouch(View v, MotionEvent event) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; return false; &#125; int action = event.getAction(); switch (action) &#123; case MotionEvent.ACTION_UP: &#123; AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(v.getContext(), R.animator.view_alpha_out_animator); set.setTarget(v); set.start(); &#125; break; case MotionEvent.ACTION_DOWN: &#123; AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(v.getContext(), R.animator.view_alpha_in_animator); set.setTarget(v); set.start(); &#125; break; &#125; return false; &#125; 更多属性动画的介绍，可以参考：Android属性动画–Property Animation（一）和Android属性动画—Property Animation（二） Bug分析思考与记录Bug1:横向图片马赛克操作会报空指针分析之前代码在onPathEvent方法中定义了马赛克操作不能超过图片尺寸的边界限制，所以对于横向图片，当手指从边界外划到边界里时，只能识别到ACTION_MOVE手势（前面由于在边界外，没有执行到ACTION_DOWN就返回了），这样也就只执行了ACTION_MOVE里面的代码，mTouchPath没有实例化，会报空指针错误。 方案取消边界限制，让ACTION_DOWN里面的实例化以及其他初始化操作在任何时候都能执行到。 Bug2:点击删除-撤销-删除后无法最终删除图片这个Bug最初是由于我快速随便点按才出现的，刚开始不知道Bug是偶现还是必现，后来慢慢操作了很多次（总的加起来应该有1个多小时），终于发现这个Bug是必现的，操作步骤就是：删除-撤销-删除。在思考的过程中，也走了一些弯路才最终定位到问题的地方，在此记录下来，下次遇到类似的非崩溃型Bug应该如何思考： 与Bug出现相关的方法多打Log，Log打的位置要有选择：分析某个方法里面代码分成几段（例如哪里有return的，可能导致该方法中途就退出的），分别插入Log 再根据Bug出现的步骤进行复现，分析Log，看最终导致Bug出现的原因 这个Bug产生的原因是：删除图片所需的Zfid为空，deleteFileAndUpdate方法没有执行完就已经退出。最终通过修改FileUtil类里的parseHeaderZfid方法，解决了这个Bug。 Bug3:performing stop of activity that is not resumed分析这个Bug是非崩溃型的，刚开始报错的时候都没有去注意它，后来有空了，在stackoverflow找到相应的答案，在没门儿的场景里面产生这个报错的原因是： 进行完临时保存图片（非加密）的task以后，在回调中要进行跳转到另外一个activity 在跳转之前，要restartCameraPreview，涉及到UI操作，所以用handler发送emptyMessage，在再handleMessage里进行处理 开始的时候跳转activity的操作直接在回调里面进行 跳转时执行onStop，但当前activity的重启操作还没有进行完，也就是没有执行onResume 方案将跳转activity的操作也在handleMessage里面处理，位置在restartCameraPreview后面，这样就保证了SecureCameraActivity重启完，再进行跳转，也就不会报上面的错了。 小知识点xmlns属性xmlns是xml namespace的缩写，标准的格式是xmlns:namespace-prefix=&quot;namespaceURI&quot;，这个属性需要定义在最外层开始的标记中，并且所有带有相同prefix的子元素都会与这个命名空间（namespace）相关联。如果没有在最外层定义相关的命名空间，子元素也就不能使用该命名空间。一般常用的命名空间有： xmlns:android=”namespaceURI” xmlns:app=”namespaceURI” xmlns:tools=”namespaceURI” 对于自定义控件，可以自定义xmlns，具体参考:xmlns:android作用以及自定义布局属性 string.xml中%1$s、%1$d等用法如果在string.xml中定义的部分内容需要在代码中进行替换，则可以用%1$s这样的用法，具体用法如下： 格式 %1$s（表示第1个需要替换的位置，是字符串类型） %1$d（表示第1个需要替换的位置，是整型类型） %1$f（表示第1个需要替换的位置，是浮点数类型） %2$d（表示第2个需要替换的位置，是整型类型） 用法 在string.xml进行定义，例如：&lt;string name=&quot;photo_import_progress&quot;&gt;正在导入(%1$d/%2$d),请稍后...&lt;/string&gt; 在代码中用getString(R.string.photo_import_progress, int, int)或者String.format(getString(R.string.photo_import_progress), int, int)来进行替换组成新的字符串 swtich-case代码规范–case后面有没有大括号的区别不加大括号整个switch里面的case都在一个作用域里，相同的变量只能初始化一次。 加大括号每个case里面都是一个作用域，相同的变量名可以在各自作用域里进行初始化，而不会互相影响。为了保险起见，最好在case后面都加上大括号，避免作用域问题引起程序编译问题。详细说明参考：java Switch中的case后面加上大括号({})和不加大括号的区别 判断用户是否第一次进入应用以显示介绍页将应用的VersionCode用SecurePreferences类进行保存，有两种情况： 新用户：mSharedPrefs.getString(mPreferencesFirstIn, &quot;&quot;)为空，此时进入IntroductionActivity 老用户升级以后：mSharedPrefs.getString(mPreferencesFirstIn, &quot;&quot;)获得的VersionCode跟保存着的老版本不一样，此时也进入IntroductionActivity。等用户点击开始体验进入应用后，将VersionCode进行保存，这样第二次进入时，就不会再显示介绍页 onActivityResult方法如果在页面跳转时如果使用了startActivityForResult方法，那当返回当前页面时，传回来的值，可以重写onActivityResult方法来完成自己想要的一些操作，在V1.3.2.0版本开发过程中，规范了页面跳转的逻辑，尽量使用startActivityForResult进行页面跳转，并用RESULT_CANCEL、RESULT_OK等进行传值，而不是像以前一样每次都重新startActivity，造成不必要的浪费。 注意点在开发过程中，由于QQ分享的回调也要重写onActivityResult方法，放开始的时候，没有判断requestCode，造成QQ分享回调一直不成功，后来才被告知是没有判断requestCode，造成回调也无法判断。所以在以后进行开发时，要把requestCode和resultCode一起进行判断，避免跟其它一些返回的值有冲突。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"MME_v1.3.0_开发个人总结","date":"2015-08-30T13:34:46.000Z","path":"2015/08/30/20150830-mme-v1.3.0-dev-summary/","text":"图片上传功能图片上传流程 采用application/octet-stream的格式上传文件，所以要拿到要上传的图片的临时路径，完成上传操作后（不管是否上传成功），都删除这个临时路径，避免系统存储过多无用文件 将文件当作参数，放入RequestParams对象中去 这里采用的是put方法进行上传，上传操作用的是android-async-http这个开源框架 服务器的返回操作在JsonHttpRespnseHandler里面处理：如果成功，返回一个Json数据，里面包含一个url；如果失败，则提示网络不佳，请重新上传 图片上传要注意的点上传签名校验为了保证服务器只接收MME应用里面发出来的数据，对发出来的数据进行了签名校验，校验格式参照接口文档以及具体代码。 上传的文件内容被修改刚开始调通上传接口之后，服务端接收到的图片无法打开，显示文件被损坏，在对文件数据进行分析后发现，文件的头部内容被修改，假如了这张图片上传的一些基本信息，而这又是用android-async-http上传文件的一种标准格式：RequestParams对象会将基本信息跟文件本身合在一起上传，文件内容是一定会被改变的。最后的解决方案是，服务端对于这种上传格式进行了识别，支持了这种上传方式。 网络状况不好的bug在最后上线之前的测试中，发现程序最终会弹出网络不佳，请重新上传的Toast，但是抓包的数据显示，服务端最终会返回一个url，说明上传最终又是成功的，这个问题最终还没有确定是服务端的问题（是否返回了两次statusCode）,还是客户端的上传回调的问题。 其它抓包工具Charles因为这版开发涉及到与服务端的交互，所以需要使用抓包工具，来分析客户端与服务端之间的数据交互。Mac端最常用的一个抓包工具叫Charles，使用也非常方便。网上的教程参考：Mac上的抓包软件Charles 横屏拍照保存异常的Bug之前的相机如果横屏拍照，保存的图片也是横屏的，不会进行相应的翻转，特别是在用前置摄像头拍照时，出现保存的照片是反着的情况。如果要实现图片正常保存，就要用OrientationEventListener这个抽象类，实现其onOrientationChanged这个抽象方法，来时时获取相机这时候的角度（通过Sensor）。在具体判断横屏竖屏时，下面代码封装了一个方法，某个范围内的角度，程序会认定它是竖屏，其它的角度，则会认定是横屏。 最后会对Camera.Parameters进行setRotation操作。12345678910111213141516171819private void onOrientationChanged(int orientation) &#123; if (orientation == OrientationEventListener.ORIENTATION_UNKNOWN) return; if (mCameraController == null) &#123; return; &#125; orientation = (orientation + 45) / 90 * 90; this.currentRotation = orientation % 360; int newRotation = 0; int cameraOrientation = mCameraController.getCameraOrientation(); if (mCameraController.isFrontFacing()) &#123; newRotation = (cameraOrientation - orientation + 360) % 360; &#125; else &#123; newRotation = (cameraOrientation + orientation) % 360; &#125; if (newRotation != currentRotation) &#123; this.currentRotation = newRotation; &#125;&#125; 相机开发流程参考下面的网页里有详细介绍了相机开发的思路和流程，备用：相机开发流程参考","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"MME_v1.2.0_改版后_开发个人总结","date":"2015-08-08T07:14:39.000Z","path":"2015/08/08/20150819-mme-v1.2.0-after-revision-dev-summary/","text":"分享功能相关微信分享总结在本次开发微信分享模块的过程中，也遇到了一些问题，下面的几点是总结： 功能需求：分享的时候可以选择原图还是缩略图。而微信API可以支持两种方式分享本地图片：本地url和bitmap。使用本地url进行分享的问题是，微信API会在拿到某个路径下的图片后对其自动进行压缩，所以就无法达到功能的要求：可以发原图或者缩略图。在这里，最终选择的是发bitmap，区别就是，原图发送的是大尺寸的bitmap，而缩略图则是发送小尺寸的bitmap。 使用微信API发送图片，WXMediaMessage类中的thumbData要传入缩略图，而这个缩略图大小又不能超过32Kb，所以要把这个缩略图大小压缩到小于32Kb才可以。 微信官方文档说分享图片或者文件的限制是10Mb，但是在实测中发现，图片大于2Mb，就会出现调不起来微信分享的情况。可能也是因为图片太大，系统生成bitmap并且进行压缩这样的耗时操作，会导致性能吃紧的情况。所以在生成bitmap时都会将从路径中拿到的图片进行压缩，操作的方式是改变BitmapFactory.Options这个类中的inSampleSize参数。 上面一点说到inSampleSize这个参数，在实际开发过程中，发现只有当参数为2的方幂时（1，2，4，8，依次往下），才会在图片尺寸上有变化。 当为1时，不压缩 当为2时，压缩1/4左右（例如：500多Kb压缩到100多Kb） 当为3时，压缩程度与2时相同 当为4时，再压缩1/4左右，之后5，6，7的压缩比例都与4相同 当为8时，再压缩1/4左右，之后再以此类推 微信分享的回调机制是在WXEntryActivity重写onResp函数来处理微信分享的返回信息，而WXEntryActivity有必须放在包名下面的wxapi这个文件夹里。 另外微信分享对于应用签名也有者严格的限制，用不同的keystore打包会生成不同的应用签名，而微信分享只认准一个应用签名，所以如果debug和release的keystore是不同的，则需要在应用正式上线前，将release版的签名再次提交审核，通过之后才能进行微信分享。 关于微信分享的其他一些细节，有一篇网上的博客也写得很详细，可以参考: Android 微信SDK分享功能中的最全过程步骤分析 图片压缩部分代码12345678910111213141516171819202122public static byte[] bmpToByteArray(final Bitmap bmp, final boolean needRecycle) &#123; ByteArrayOutputStream output = new ByteArrayOutputStream(); int compressRatio = 30; bmp.compress(CompressFormat.JPEG, compressRatio, output); //微信限制缩略图大小为32kb while (output.toByteArray().length/1024&gt;32) &#123; output.reset(); compressRatio -= 10; bmp.compress(CompressFormat.JPEG,compressRatio,output); &#125; if (needRecycle) &#123; bmp.recycle(); &#125; byte[] result = output.toByteArray(); try &#123; output.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; 上面一段代码是将一个bitmap进行压缩后，再用IO流返回一个byte数组传入WXMediaMessage中的thumbData参数。 QQ分享总结QQ分享的限制没有微信那么多，对于图片的大小也没有特殊限制，分享本地图片的方法也只有一种：本地url。只要给QQ的API一个本地url路径，它就会去那个路径下找图片，然后发送。但是MME相机出于对安全的考虑，相机里面的照片存放路径是应用私有的，如果传这个url路径给QQ分享，它的API没有权限去拿到这个路径下的图片，所以在开发过程中采用的方案是： 进行QQ分享时，先获取到当前图片解密后的应用下路径，并生成bitmap 将bitmap写入到系统公有的一个路径里，为了安全考虑，此时要将保存图片的文件夹设置为不可见，采用在文件夹名签名加“.”的方式 传入该公有的路径给QQ分享API，完成QQ分享操作 在QQ分享的回调函数IUiListener类里面将刚刚保存的图片删除（不管有没有分享成功）,也是为了安全考虑 保存到本地总结保存到本地功能有一个地方需要注意的是，在保存完成后，需要发个广播，来通知系统更新刚保存到本地相册的图片，代码是：1context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(\"file://\" + tempDir.getAbsolutePath() + \"/\" + fileName))); Android里Touch事件机制问题描述在本版开发中，有两个针对相机的功能：点击聚焦和双指缩放变焦。这两个功能都是和Touch事件相关的操作，开始的思路是对CameraPreview对象设置onTouchListener监听，然后在里面的onTouch方法实现双指缩放逻辑，但是因为原来的代码在CameraPreview类中重写了onTouchEvent方法，这样就导致了只能实现双指缩放而不能实现点击聚焦。针对这个问题，查了网上对于两者区别的比对，现在记录在下面，以后想起来可以翻一下。 onTouchListener中的onTouch方法与onTouchEvent的区别这里只写结论，分析过程可以参考android onTouchEvent和setOnTouchListener中onTouch的区别或者阅读View类里面的dispatchTouchEvent方法。 onTouchListener优先级高于onTouchEvent 系统会先执行onTouchListener中的onTouch方法，如果onTouch方法返回true，则系统会判断此次Touch事件已经执行，也就不会再去执行onTouchEvent方法；只有当onTouch返回false时，才会继续执行onTouchEvent方法 解决方案由于原来代码里面的点击聚焦功能写在CameraPreview类里，为了代码能统一起来，所以准备把双指缩放的功能也加入到onTouchEvent里面进行处理，下面是一些注意点： onTouchEvent方法需要返回true才行，否则系统无法处理此次Touch事件，直观的感受就是只会执行MotionEvent.ACTION_DOWN，而不会去执行其它的一些手势操作 MotionEvent.ACTION_MASK作用是识别多指操作 onTouchEvent中的MotionEvent.ACTION_DOWN+MotionEvent.ACTION_UP动作就等于onClick方法执行了一次 其它另外一个遗留问题是，在进行了点按聚焦后，相机的连续自动对焦功能失效，最终的解决方案是： 在CameraPreview里的touchFocus方法里重新设置连续自动对焦 两个在UI线程（主线程）更新UI的例子导入照片显示进度的Dialog 需要记录当前已经解密完成的照片数量，也要拿到总共需要导入的照片数量 在开始记录的时候，用handler发送空消息，在UI线程里面显示dialog，并且时时更新导入进度 在导入完成时，用handler发送ON_IMPORT_COUNT_END空消息，在UI线程里dismiss掉dialog 主要代码在TaskCallback&lt;Image&gt;对象的onStateChange方法里记录导入加密的情况：123456789101112131415if (image.getTaskState().equals(ImageEncryptTaskManager.EncryptTask.STATE_ENCRYPTED) &#123; mPhotoCount = mPhotoCount - 1; if (mPhotoCount == 0) &#123; handler.sendEmptyMessage(ON_IMPORT_END); &#125; mProgressCount += 1; handler.sendEmptyMessage(ON_IMPORT_COUNT); if(mProgressCount == mAdapter.getSelectedItemsCount()) &#123; mCountCompleted = true; handler.sendEmptyMessage(ON_IMPORT_COUNT_END); &#125; &#125; 显示Toast问题描述这里出现的问题是：在完成马赛克操作，点击保存进行加密保存的时候，这个过程实在子线程里进行的，会有一个onEncrypt的回调函数，刚开始的时候，把照片保存成功的Toast直接写在这个回调函数里，后面发现这样写会报错，然后代码也就不会往下执行，也无法进行页面的跳转。 解决方案在onEncrypt回调函数里面用handler发送空消息，然后重写handler里面的handleMessage方法，进行Toast显示以及页面跳转等操作。 图片保存路径问题描述在进完马赛克操作后，用户点击进行保存，刚开始的保存方式是直接调用GPUImageView类中的saveImage方法，而安全相册里面的照片都是保存在应用的私有路径里，所以刚开始的时候，在安全相册里一直看不到保存的马赛克后的图片。 解决方案参照拍照完的照片加密保存的方式，对马赛克图片也同样进行加密保存到应用的私有路径里。 几种图片路径的区别 内部存储（Internal Storage） context.getFilesDir()是将文件保存在以应用报名命名的私有目录里 context.getCacheDir()是将文件保存在应用的私有缓存目录里 外部存储（External Storage） Environment.getExternalStoragePublicDirectory（String type）是将文件保存在公有目录下，并且应用卸载后数据不会被删除 context.getExternalFilesDir(String type)是将文件保存在外部存储的根目录下，数据会随着程序被卸载而删除 通过路径获取图片的Exif信息问题描述Android系统由于是开源的，不同厂商会针对原生系统做自己的优化，对于拍照应用来说，有些厂商会对图片的旋转进行处理，而有些则不会，这就造成在有些机型上，拍摄的照片在显示时会翻转过来。 解决方案通过路径获取图片的Exif信息，得到图片的旋转角度，然后按照这个角度对图片进行翻转操作，让图片在显示的时候重新正回来。 获取图片Exif信息代码1234567891011121314151617181920212223242526272829private static int getExifOrientation(String filePath) &#123; int degree = 0; ExifInterface exif = null; try &#123; exif = new ExifInterface(filePath); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (exif != null) &#123; int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION,-1); if (orientation != -1) &#123; switch (orientation) &#123; case ExifInterface.ORIENTATION_ROTATE_90: degree = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: degree = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: degree = 270; break; &#125; &#125; &#125; return degree; &#125; 获取degree之后，再进行翻转操作，代码如下：123Matrix matrix = new Matrix();matrix.setRotate(degree,bitmap.getWidth()/2,bitmap.getHeight()/2);Bitmap bmp = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true); UI相关Button点击效果 如果想要Button里面的字有点击效果，则需要设置textColor属性，用selector来设置点击时候的颜色 如果想要Button的背景有点击效果，需要设置的是background属性 ImageButton和ImageView ImageButton的图片默认会放在中心位置，虽然可以用scaleType属性设置放在左边、中间还是右边，但是没法设置padding属性，让ImageButton在wrap_content情况下点击面积更大 而ImageView可以设置padding属性让点击面积更大 设置强制横屏的代码12setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); 如何阻止系统进行截屏操作123Window w=getWindow();w.addFlags(WindowManager.LayoutParams.FALG_SECURE); 马赛克功能马赛克功能实现机制 bmBaseLayer层，可以理解为直接拿原始图片作为最底下那一层 bmMosaicLayer层，可以理解为在bmBaseLayer上面一层，最终的马赛克图像是由两层叠加生成一个新的bitmap进行保存后形成的 对于bmMosaicLayer这一层来说，实际不是对它进行直接操作，而是在它上面进行画图操作，其中有一层是bmCoverLayer，在代码里有三种可选：GridMosaic、ColorMosaic和BlurMosaic，在我们这里选择的是GridMosaic。具体实现方式是：将图片分成一格一格，取左上角那个点的像素颜色值，然后设置成那个格子的颜色，最后进行画图 还有一层就是bmTouchLayer，是我们手进行操作的那一层，最终两层合在一起，是bmMosaicLayer Bug1:橡皮擦操作后的位置无法再次进行马赛克操作问题描述由于updatePathMosaic的机制是实时绘制马赛克和橡皮擦操作的路径集合，并且橡皮擦的绘制在后面，所以当两者路径重合时，后绘制的橡皮擦会覆盖马赛克，所以在观感上就会造成橡皮擦操作后的位置无法再次进行马赛克操作的感觉 解决方案 bmTouchLayer从局部变量变成全局变量，由它来保存马赛克和橡皮擦操作后的图层，而之前是由一个Path集合来分别保存马赛克和橡皮擦的路径 每次进行操作之前，清空Path集合里面的路径 Bug2:某些小图片上划过的Path和Grid宽度很大问题描述尺寸较小的图片进入马赛克页面后会进行拉伸处理，之前对于Path和Grid的宽度都是采用一个固定值，这样就会造成小图上进行马赛克处理时划过的Path和Grid宽度很大 解决方案 对于Grid的宽度问题，根据图片宽度设置几个Level，每个Level固定每行Grid的个数，这样也就不会造成小图片每行只有一两个Grid的情况，但是对于Grid的宽度也有一个极限值是50，因为如果不做处理，非常大的图片一行也只有20个Grid，就会造成每个Grid的宽度特别大 对于Path宽度的问题，小图设置宽度较小，大图设置宽度较大 主要代码1234567891011121314if (mImageWidth &lt; 200) &#123; mGridWidth = mImageWidth/10; mPathWidth = dp2px(3); &#125; else if (mImageWidth &lt; 500) &#123; mGridWidth = mImageWidth/15; mPathWidth = dp2px(10); &#125; else &#123; mGridWidth = mImageWidth/20; mPathWidth = dp2px(20); &#125; if (mGridWidth &gt; 50) &#123; mGridWidth = 50; &#125; Bug3:马赛克页面图片显示比例失真问题描述原来的方案：没有按照图片原来宽高比的尺寸进行压缩或者拉伸，这样子对于有些图片显示出来就会有比例失真的问题 解决方案 核心思路：图片无论如何都要按照原有图片的宽高比来进行缩放显示 具体操作1：当宽&gt;高时，让宽充满View，再按照原始宽高比计算出新的高的值 具体操作2：当高&gt;宽时，让高充满View，再按照原始宽高比计算出新的宽的值，例外情况：当计算出的新宽值大于View的宽值时，改变方式，让宽充满View，再按照原始宽高比计算出新的高的值 主要代码1234567891011121314151617181920212223242526272829303132333435363738394041 int contentWidth = right - left; int contentHeight = bottom - top; int viewWidth = contentWidth ; int viewHeight = contentHeight ; float widthRatio = viewWidth / ((float) mImageWidth); float heightRatio = viewHeight / ((float) mImageHeight); float ratio = widthRatio &lt; heightRatio ? widthRatio : heightRatio; int realWidth ,realHeight; if (mImageWidth &gt;= mImageHeight) &#123; float heightWidthRatio = mImageHeight / ((float) mImageWidth); realWidth = new BigDecimal(mImageWidth * widthRatio).setScale(0,BigDecimal.ROUND_HALF_UP).intValue(); realHeight = new BigDecimal(realWidth * heightWidthRatio).setScale(0,BigDecimal.ROUND_HALF_UP).intValue(); imageLeft = (contentWidth - realWidth) / 2; imageRight = imageLeft + realWidth; imageTop = (contentHeight - realHeight) / 2; imageBottom = imageTop + realHeight; &#125; else &#123; float widthHeightRatio = mImageWidth / ((float) mImageHeight); realHeight = new BigDecimal(mImageHeight * heightRatio).setScale(0,BigDecimal.ROUND_HALF_UP).intValue(); realWidth = new BigDecimal(realHeight * widthHeightRatio).setScale(0,BigDecimal.ROUND_HALF_UP).intValue(); if (realWidth&lt;=contentWidth) &#123; imageLeft = (contentWidth - realWidth) / 2; imageRight = imageLeft + realWidth; imageTop = (contentHeight - realHeight) / 2; imageBottom = imageTop + realHeight; &#125; else &#123; float heightWidthRatio = mImageHeight / ((float) mImageWidth); realWidth = new BigDecimal(mImageWidth * widthRatio).setScale(0,BigDecimal.ROUND_HALF_UP).intValue(); realHeight = new BigDecimal(realWidth * heightWidthRatio).setScale(0,BigDecimal.ROUND_HALF_UP).intValue(); imageLeft = (contentWidth - realWidth) / 2; imageRight = imageLeft + realWidth; imageTop = (contentHeight - realHeight) / 2; imageBottom = imageTop + realHeight; &#125; &#125;mImageRect.set(imageLeft,imageTop,imageRight,imageBottom);","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"MME_v1.2.0_开发个人总结","date":"2015-07-14T02:11:23.000Z","path":"2015/07/13/20150714-mme-v1.2.0-dev-summary/","text":"界面布局重叠View导致button点击失效的处理方案调整相机参数的几个功能是由最左边的“option button”来点击触发的，触发之后，会有一个“match_parent”的黑色半透明view，刚开始采用的是RelativeLayout，这样就会造成button和下面的view重叠，导致button点击事件失效。在回忆了当时学习Android Layout方面的知识之后，并且用eclipse的monitor解析了一个类似界面的app的布局，意识到这个问题可以用FrameLayout来实现，因为FrameLayout默认的排版就是将view按照添加的先后顺序堆在屏幕的左上角。需要注意的是：FrameLayout只支持下面三种方式来调整排版的位置： layout_gravity layout_marginXXX layout_paddingXXX SeekBar上数值随着thumb移动如何实现最重要的是求出thumb移动时的X轴坐标位置（如果seekbar是竖直的，则为Y轴坐标位置），重写SeekBar类中的onDraw(Canvas c)方法，用c.drawText(String s,float x,float y,Paint p)来实时绘制thumb上面的数值，thumb的X坐标位置+Y坐标位置（需要稍微改变下，避免与thumb重合）传入c.drawText方法中。 注意点： 如果传入的数据需要外面的函数确定，则需要在重写类里写相关的实现函数。 由于thumb本身有大小之分，也有offset，数值的位置使用计算出的thumb的X轴坐标会跟thumb本身有些偏差，需要进行一些调整。 另一种解决方案是SeekBar+PopupWindow，具体例子：SeekBar+PopupWindow 自定义Toast由于一般用户在点击切换闪光灯时都会很快速切换好几个状态，此时Toast就要满足下一个Toast出现的时候覆盖掉上一个Toast，如果不做一些限制，则Toast会按照顺序一个一个将动画效果执行完，就会出现用户执行完操作很长时间之后Toast还在进行切换。所以在这里自定义Toast做了如下的判断：123456if (mToast != null) &#123; mTextViewToast.setText(text); &#125; else &#123; mToast = new Toast(mContext); mTextViewToast.setText(text); &#125; 上面这段代码的意思就很容易明白了，如果mToast不为空，则立马替换里面的Text；如果为空，则先创建实例，在setText。这样就能实现每次点击，Toast实时更新。 动画相关切换摄像头的3d旋转动画Rotate3dAnimation是Android API Demos里面的一个类，如果第三方SDK里面没有，可以自己借鉴Android API Demos里面写一个。旋转的角度是从0-90°再到270°-360°，使用了两次Rotate3dAnimation的动画效果，实现镜头绕着屏幕中间的Y轴旋转360°的效果。这个动画的主要目的是在切换镜头的时候，实现顺滑过渡。实现思路借鉴：郭霖的博客–Android中轴旋转特效实现 Interpolator的使用Android中默认的Interpolator有AccelerateInterpolator、BounceInterpolator、AccelerateDecelerateInterpolator、AnticipateOvershootInterpolator等等，主要的作用就是Android动画的变化率，特别是BounceInterpolator，模仿的是物体自由落体的运动，会有几次回弹的效果，如果在使用时不满足项目要求，可以自己重写里面的回弹函数，可以控制回弹的次数以及回弹幅度。 遇到的问题如果对某个button直接采用imagebutton.animate().rotation().setListener()的形式加载动画，onAnimationEnd()方法会执行两次，导致imagebutton最终的动画效果不是自己想要的，暂时没有找到问题在哪。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"JeffinBaoCV--个人简历开发总结","date":"2015-05-17T08:50:13.000Z","path":"2015/05/17/20150517-jeffinbaocv-summary/","text":"开发思路由于之前在网上看到了这样一份简历：作者把自己的经历采用类似于地图搜路径的方式呈现了出来，大致排版与Google Map很像，左边是模拟搜索后的文字版路径，右边则是地图中各个关键节点，一页纸就把自己的经历以一种很巧妙的形式展现了出来。当时看了之后，觉得作者很有创意，接着就自己在琢磨，他的简历最终是静态的pdf或者word形式，既然是以地图搜索的形式，能不能动态展现自己的经历呢：点击左边的某个具体点，右边地图上会有反馈，并且点击点图上的节点，会有该阶段个人的一个详细经历。 想要有这样的效果，在网页上呈现，那html，js，css知识肯定是必不可少的。由于自己对于Android开发的兴趣比较大，初学编程接触的也是Java和Android，所以后来的想法就是，这样一份简历能不能最终以APP的形式呈现出来。 有了想法的改变后，如何实现是接下来思考的问题。考虑到手机屏幕较小，原本在电脑端可以以一个版面呈现的简历在手机上要分成这样几个界面： 初始搜索界面（类似于地图首页搜索） 路径（人生经历）呈现界面 每个人生阶段的地图界面 该人生阶段的具体介绍界面 上面的想法是借鉴手机上地图应用的逻辑：进入应用会有搜索框，搜索之后给出多重路径规划，针对某个路径会有具体的导航。至于该人生阶段的具体介绍界面，则会通过点击地图上的Marker来呈现一个界面。 具体实现过程初始搜索界面1.输入“包建峰”，点击“搜索”按钮。这个操作背后会有这样几个动作： 在地图上绘制全部路径和Marker，想要达到在地图上整体呈现我的人生轨迹的效果 将后续要用到的数据分类存入数据库中，包括地点名称、经纬度、人生经历的具体描述 出现一个圆形“出发”按钮，点击后可以进入“路径（人生经历）呈现界面” 2.第一个界面没有较大难点，动画效果也只有地图从远到近的缩放效果 路径（人生经历）呈现界面1.采用ScrollView并且里面有多层嵌套的LinearLayout来完成横向竖向都有的内容布局，主要内容是个人在每个地点的主要学习和工作职责。 2.每个地点都有一个点击事件，分别指向地图界面对应的城市位置 每个人生阶段的地图界面1.上一个Activity的不同点击事件会传来不同的Integer值，由此Integer值判断地图界面应该处于哪个城市，进而移动到目标位置区域并画上Marker 2.ViewPager可以让地图顶端的地点进行左右滑动，以此来出发地图上位置的改变，注意这里要重写ViewPager.OnPageChangeListener中的onPageSelected方法，而PlaceHolderFragment类中的onCreateView方法仅仅是用来加载ViewPager上的内容，并且会预加载下一个或者上一个view,position最后的值不是当前位置，所以不适合在该方法里面触发位置改变。 3.除了滑动操作之外，也可以点击左右的箭头按钮前进到下一个地点或后退到上一个地点。需要注意的是当地点处于起点或者终点时，只有向前按钮或者只有后退按钮，这个逻辑判断请见下面一段代码示例： 123456789currentPageId=arg0;if (currentPageId==0) &#123; imageButtonLeft.setVisibility(View.INVISIBLE);&#125; else if (currentPageId==5) &#123; imageButtonRight.setVisibility(View.INVISIBLE);&#125; else &#123; imageButtonLeft.setVisibility(View.VISIBLE); imageButtonRight.setVisibility(View.VISIBLE);&#125; 4.Marker点击事件，会跳转到Dialog样式的Activity里，呈现在该地点的具体个人经历 该人生阶段的具体介绍界面1.虽然是Activity，但是想要一种临时弹出Dialog的效果，所以就自定义了Activity的大小，代码如下： 123456789WindowManager wm = getWindowManager();Display d = wm.getDefaultDisplay(); LayoutParams lp = getWindow().getAttributes();lp.width = (int)(d.getWidth() * 0.88);lp.height = (int)(d.getHeight() * 0.7);lp.y = 100;getWindow().setGravity(Gravity.CENTER);getWindow().setAttributes(lp); 2.由于同时使用了ListView和ScrollView会造成冲突，所以写了一个MyListView继承ListView，并且重写了ListView的onMeasure方法，代码如下： 1234protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec) &#123; int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE&gt;&gt;2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec); &#125; 3.为了主要任务和达成情况滚动到顶部时有悬停的效果，需要写一个StickyScrollView继承ScrollView。代码请看JeffinBaoCV中的StickyScrollView.java 问题总结1.BaseTransformer.java里面的onPreTransform方法需要进一步理解体会 2.MyListView.java里面onMeasure方法中Integer.MAX_VALUE&gt;&gt;2的作用？ 3.StickyScrollView里面showStickyView方法需要进一步理解体会 4.StickyScrollView里面第一个构造函数为什么要用this(context,attrs,0);,有什么具体作用吗？","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"O2O行业下沉难点与可能的推广方式--三四线城市","date":"2015-04-28T06:06:53.000Z","path":"2015/04/28/20150428-O2O-hard-points-and-marketing-plan/","text":"促使我写本文的诱因是今年过年在家的一个小事情：大年三十早上约了同学出去玩，因为老爸车开走了，我又快赶不上时间了，抱着试试看的想法，拿出了手机用滴滴打车叫了车。在加价5元（另外滴滴打车还有加价4元给司机师傅）的前提下，有一位司机过来接我并把我送到了目的地。上车之前，我意淫着：这真的是改变啊，大年三十从来不打表的临海还能用打车软件打到车并且打表送我到目的地。所以上车后，也就开心地跟司机闲聊着，车上聊得内容总结起来有以下几点： 临海的出租车司机基本没有使用快的打车，使用滴滴打车的司机大概有40-50人（数据真实性未知，但能反应司机使用的人数很少） 每天通过打车软件接单4-5单左右，很少 为什么会这样？司机师傅给出一个解释：临海的私家车保有量比较高，出租车生意本身就没以前好做了，也就是说出租车的用车情况不紧张，路边随手拦车的成功率较高（除非一点偏远地点，例如我家位置偏郊区）。 下车之后，我也没细想，但是隐隐得感觉在一二线城市风生水起的各种移动互联网创业公司的产品在这个四线城市显得没有太多用武之地。直到上个星期，看到这样一条微博（只复述大致意思）：微博团队因为发现新用户增长乏力，派出两组人员，分别在江西九江和湖北宜昌待了半年做市场调研。发现确实微博在这样的三四线城市使用率极低，首先由于三四线城市没有开通运营商的数据流量功能的用户就有很多，再者就算开通了数据流量的用户，因为微博上没有什么内容是他们感兴趣的，使用的人也很少。最后微博团队的方案是，扶植本地“大V”，让内容更“接地气”。 说实话，看到这条微博的时候，我感觉自己脑子被打了一拳一样：微博这么有影响力的产品在三四线城市也有这样的问题啊，那其他一些“明星”创业公司，不更是这样？移动互联网创业公司涉及的范围很广，社交类，O2O类等等，我只对O2O类进行论述思考，因为生活类O2O还有可能在三四线城市发生点什么，而像无秘这样的应用，实在想不出它下沉到三四线城市，能为我爸妈这样年纪的人带来些什么。 之后我在想，微博的问题是大多数公司产品在下沉到三四线城市都会遇到的，那有没有做得比较好的呢？我认为是微信（QQ是从互联网时代走来的，不算是从移动互联网时代开始的产品），据报道称，截止到2014年底，微信的用户已经过5亿，虽然少于QQ的8亿多，但短短4年时间，从0做到5亿，我认为不单单是依靠QQ这颗大树，微信在很多方面都有很厉害的地方。所以我也就拿微信做了一个小范围的数据调查，结果见下表： 注： 数据来源是我自己的朋友圈，以及另外7位小伙伴的朋友圈（感谢小伙伴们），经统计，共有165份有效的答复。 由于样本数量不足够大，并且朋友圈人群得相似性，下面得出的结论仅基于这组数据的分析以及扩展猜测。 答复中有多选的情况，被视为无效答复，因为这里要统计的是明确使父母开始使用微信的缘由。 图表数据解释： 由子女推荐开始使用的父母总共有57人，占比为34.55%，比例最高。 父母自己了解并主动使用共有46人，占比为27.87%，比例次之。 到目前为止还未使用微信的父母共有31人，占比为18.79%，比例排名第三 数据扩展猜测： 由子女推荐开始使用的比例最高符合我在做调查之前的预测，三四线城市父母平时接触这些新新事物的渠道有限，从子女口中得知这些是一个非常重要的渠道，并且现实中却有强沟通需求。微信的语音功能，对于打字不太熟练的40岁+中年人来说是神来之笔。 父母自己了解并主动使用比例次之有点出乎我的预料，但是从反馈的数据来说，此类父母受过良好教育，工作类型属于事业单位公务员的较多，具体职业主要有以下几种：教师，银行，医生，公务员等。说明此类父母接触使用新事物的能力较强，这与他们的学历，见识有一定的相关度。此类父母可以被认为是三四线城市的Innovator和Early Adopter。 到目前为止还未使用微信的父母比例排名第三，从我自己朋友圈的大致情况看，此类父母年纪应该在55-60岁左右居多（对应孩子的年纪在30岁+），因为这部分人群年龄较大，就算能够通过一些渠道了解这些新事物，学习使用的意愿和能力也是比较弱的。 由上面数据的扩展猜测，也就引出了下面我大胆猜测O2O行业下沉到三四线城市的可能推广方式： 能不能由接触新事物能力较强的子女来反哺父母，除了年轻人之外，再继续抓住年龄在40-60岁之间的“父母”。方式可以是，由子女来邀请父母使用产品，邀请成功的子女和父母都会得到优惠，为了培养用户，开始阶段的优惠力度不能够太低。在推广过程中可能遇到的问题：如果子女推荐的不是父母怎么办，而推荐的是其他朋友呢？由于O2O行业的特殊性，大部分的交易服务过程是发生在线下的，在服务过程中也就很好判断子女推荐的是不是“父母”。其实对于公司来说，是不是“父母”不是最关键的，关键的是推荐的“父母”是不是在40-60岁这个年龄段里面。 对于接触和使用新事物能力较强的父母来说，地推团队是否有足够的能力，与企业和事业单位等进行合作，精准针对这部分人进行推广优惠活动。与企事业单位的合作看起来是比较困难的，所以地推团队的本地化相当重要，能否找到在当地拥有人脉的相关人员也考验公司的市场和公关能力。 以上推广方式的猜测肯定是不成熟甚至不正确的，因为O2O行业到底能给三四线城市带来什么的问题还是很难回答。生活类O2O行业由于具有即时性的特点，用户在使用它的时候会对它有个判断：我用了它之后会不会给我带来方便（不管是时间上的还是金钱上的）。这一点使得生活类O2O产品在一二线城市就有相关的使用场景，下面举2个例子： 打车，特别是高峰时段的打车。由于一二线城市人口多，每天的上下班高峰各种交通工具都要超负荷运送人们上班下班。这个时候，如果还是传统的方式，在路上很难打到车。打车软件匹配了司机端和乘客端的信息，提升了效率，并且乘客可以选择加小费来吸引司机来接自己，目前更多的方式也正在出现：专车，上下班拼车回家等。但是这样的场景在三四线城市是很少的，首先上下班的压力本身就没那么大，加上有些城市的私家车保有量很高（经济较发达地区），另外因为城市比较小，步行以及骑车上下班的比例应该是大于一二线城市的，这也就意味着上下班的交通工具种类比较丰富，不像一二线城市大部分只能是出租车，公交车，私家车。 餐饮类。外卖类以及吃饭等位类O2O最近在一二线城市使用人群也在飞速增加，主要解决了上班族们工作日希望快速解决吃饭问题以及休息日时出去搓一顿但又怕排队时间太长的问题。曾经一次在海岸城等吃一家饭店等了2个半小时，现在等位可以移到“美味不用等”这样的吃饭等位类微信公众账号上来进行。 而这样的场景同样在三四线城市基本上是很难见到的，三四线城市的繁荣程度远达不到一二线城市。在临海最火的饭店吃饭等位也不可能到2个半小时，原因可能有以下几点： 人本身就没有那么多 三四线城市本地特色的小吃饭店选择比较多，而一二线城市口味较好的饭店基本都是连锁的品牌，顾客可选择度较小 举以上两个例子是想说明，可能很多生活类O2O产品在三四线城市就没有很大的需求并且也解决不了实际问题（就目前的情况来说）。虽然一二线城市意味着更多的机会，但三四线城市的日常生活便利性也是一二线城市没法比的，这里的日常生活范畴不包括那些精致的产品以及精品的服务。所以生活类O2O在下沉到三四线城市之前能否了解到某个细分领域在三四线城市是否存在很大的问题是很重要的，另外如果O2O产品进入，又能给这些问题带来什么样的改变？ 但是想要做Next Big，又必须下沉到三四线城市这个更广大的市场，虽然他们是沉默的大多数。","tags":[{"name":"杂文","slug":"杂文","permalink":"http://yoursite.com/tags/杂文/"},{"name":"科技","slug":"科技","permalink":"http://yoursite.com/tags/科技/"}]}]